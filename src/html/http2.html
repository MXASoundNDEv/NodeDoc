<!DOCTYPE html>
    <html>
      <button onclick="history.back()" id="BACKBUTTON" title="Go to top">Back</button>
      <link rel="stylesheet" href="../css/default.css" />
    <head>
        <meta charset="UTF-8">
        <title>HTTP&sol;2</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="http2">HTTP/2</h1>
<!-- YAML
added: v8.4.0
changes:
  - version:
      - v15.3.0
      - v14.17.0
    pr-url: https://github.com/nodejs/node/pull/36070
    description: It is possible to abort a request with an AbortSignal.
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34664
    description: Requests with the `host` header (with or without
                 `:authority`) can now be sent/received.
  - version: v10.10.0
    pr-url: https://github.com/nodejs/node/pull/22466
    description: HTTP/2 is now Stable. Previously, it had been Experimental.
-->
<!--introduced_in=v8.4.0-->
<blockquote>
<p>Stability: 2 - Stable</p>
</blockquote>
<!-- source_link=lib/http2.js -->
<p>The <code>http2</code> module provides an implementation of the <a href="https://tools.ietf.org/html/rfc7540">HTTP/2</a> protocol. It
can be accessed using:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
</div></code></pre>
<h2 id="core-api">Core API</h2>
<p>The Core API provides a low-level interface designed specifically around
support for HTTP/2 protocol features. It is specifically <em>not</em> designed for
compatibility with the existing <a href="http.html">HTTP/1</a> module API. However,
the <a href="#compatibility-api">Compatibility API</a> is.</p>
<p>The <code>http2</code> Core API is much more symmetric between client and server than the
<code>http</code> API. For instance, most events, like <code>'error'</code>, <code>'connect'</code> and
<code>'stream'</code>, can be emitted either by client-side code or server-side code.</p>
<h3 id="server-side-example">Server-side example</h3>
<p>The following illustrates a simple HTTP/2 server using the Core API.
Since there are no browsers known that support
<a href="https://http2.github.io/faq/#does-http2-require-encryption">unencrypted HTTP/2</a>, the use of
<a href="#http2createsecureserveroptions-onrequesthandler"><code>http2.createSecureServer()</code></a> is necessary when communicating
with browser clients.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> server = http2.createSecureServer({
  <span class="hljs-attr">key</span>: fs.readFileSync(<span class="hljs-string">&#x27;localhost-privkey.pem&#x27;</span>),
  <span class="hljs-attr">cert</span>: fs.readFileSync(<span class="hljs-string">&#x27;localhost-cert.pem&#x27;</span>)
});
server.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  <span class="hljs-comment">// stream is a Duplex</span>
  stream.respond({
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>,
    <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>
  });
  stream.end(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);
});

server.listen(<span class="hljs-number">8443</span>);
</div></code></pre>
<p>To generate the certificate and key for this example, run:</p>
<pre><code class="language-bash"><div>openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj <span class="hljs-string">&#x27;/CN=localhost&#x27;</span> \
  -keyout localhost-privkey.pem -out localhost-cert.pem
</div></code></pre>
<h3 id="client-side-example">Client-side example</h3>
<p>The following illustrates an HTTP/2 client:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;https://localhost:8443&#x27;</span>, {
  <span class="hljs-attr">ca</span>: fs.readFileSync(<span class="hljs-string">&#x27;localhost-cert.pem&#x27;</span>)
});
client.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-keyword">const</span> req = client.request({ <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span> });

req.on(<span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers, flags</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> headers) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${headers[name]}</span>`</span>);
  }
});

req.setEncoding(<span class="hljs-string">&#x27;utf8&#x27;</span>);
<span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span>;
req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { data += chunk; });
req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${data}</span>`</span>);
  client.close();
});
req.end();
</div></code></pre>
<h3 id="class-http2session">Class: <code>Http2Session</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {EventEmitter}</li>
</ul>
<p>Instances of the <code>http2.Http2Session</code> class represent an active communications
session between an HTTP/2 client and server. Instances of this class are <em>not</em>
intended to be constructed directly by user code.</p>
<p>Each <code>Http2Session</code> instance will exhibit slightly different behaviors
depending on whether it is operating as a server or a client. The
<code>http2session.type</code> property can be used to determine the mode in which an
<code>Http2Session</code> is operating. On the server side, user code should rarely
have occasion to work with the <code>Http2Session</code> object directly, with most
actions typically taken through interactions with either the <code>Http2Server</code> or
<code>Http2Stream</code> objects.</p>
<p>User code will not create <code>Http2Session</code> instances directly. Server-side
<code>Http2Session</code> instances are created by the <code>Http2Server</code> instance when a
new HTTP/2 connection is received. Client-side <code>Http2Session</code> instances are
created using the <code>http2.connect()</code> method.</p>
<h4 id="http2session-and-sockets"><code>Http2Session</code> and sockets</h4>
<p>Every <code>Http2Session</code> instance is associated with exactly one <a href="net.md#class-netsocket"><code>net.Socket</code></a> or
<a href="tls.md#class-tlstlssocket"><code>tls.TLSSocket</code></a> when it is created. When either the <code>Socket</code> or the
<code>Http2Session</code> are destroyed, both will be destroyed.</p>
<p>Because of the specific serialization and processing requirements imposed
by the HTTP/2 protocol, it is not recommended for user code to read data from
or write data to a <code>Socket</code> instance bound to a <code>Http2Session</code>. Doing so can
put the HTTP/2 session into an indeterminate state causing the session and
the socket to become unusable.</p>
<p>Once a <code>Socket</code> has been bound to an <code>Http2Session</code>, user code should rely
solely on the API of the <code>Http2Session</code>.</p>
<h4 id="event-close">Event: <code>'close'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'close'</code> event is emitted once the <code>Http2Session</code> has been destroyed. Its
listener does not expect any arguments.</p>
<h4 id="event-connect">Event: <code>'connect'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>session</code> {Http2Session}</li>
<li><code>socket</code> {net.Socket}</li>
</ul>
<p>The <code>'connect'</code> event is emitted once the <code>Http2Session</code> has been successfully
connected to the remote peer and communication may begin.</p>
<p>User code will typically not listen for this event directly.</p>
<h4 id="event-error">Event: <code>'error'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>error</code> {Error}</li>
</ul>
<p>The <code>'error'</code> event is emitted when an error occurs during the processing of
an <code>Http2Session</code>.</p>
<h4 id="event-frameerror">Event: <code>'frameError'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>type</code> {integer} The frame type.</li>
<li><code>code</code> {integer} The error code.</li>
<li><code>id</code> {integer} The stream id (or <code>0</code> if the frame isn't associated with a
stream).</li>
</ul>
<p>The <code>'frameError'</code> event is emitted when an error occurs while attempting to
send a frame on the session. If the frame that could not be sent is associated
with a specific <code>Http2Stream</code>, an attempt to emit a <code>'frameError'</code> event on the
<code>Http2Stream</code> is made.</p>
<p>If the <code>'frameError'</code> event is associated with a stream, the stream will be
closed and destroyed immediately following the <code>'frameError'</code> event. If the
event is not associated with a stream, the <code>Http2Session</code> will be shut down
immediately following the <code>'frameError'</code> event.</p>
<h4 id="event-goaway">Event: <code>'goaway'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>errorCode</code> {number} The HTTP/2 error code specified in the <code>GOAWAY</code> frame.</li>
<li><code>lastStreamID</code> {number} The ID of the last stream the remote peer successfully
processed (or <code>0</code> if no ID is specified).</li>
<li><code>opaqueData</code> {Buffer} If additional opaque data was included in the <code>GOAWAY</code>
frame, a <code>Buffer</code> instance will be passed containing that data.</li>
</ul>
<p>The <code>'goaway'</code> event is emitted when a <code>GOAWAY</code> frame is received.</p>
<p>The <code>Http2Session</code> instance will be shut down automatically when the <code>'goaway'</code>
event is emitted.</p>
<h4 id="event-localsettings">Event: <code>'localSettings'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object} A copy of the <code>SETTINGS</code> frame received.</li>
</ul>
<p>The <code>'localSettings'</code> event is emitted when an acknowledgment <code>SETTINGS</code> frame
has been received.</p>
<p>When using <code>http2session.settings()</code> to submit new settings, the modified
settings do not take effect until the <code>'localSettings'</code> event is emitted.</p>
<pre><code class="language-js"><div>session.settings({ <span class="hljs-attr">enablePush</span>: <span class="hljs-literal">false</span> });

session.on(<span class="hljs-string">&#x27;localSettings&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
  <span class="hljs-comment">/* Use the new settings */</span>
});
</div></code></pre>
<h4 id="event-ping">Event: <code>'ping'</code></h4>
<!-- YAML
added: v10.12.0
-->
<ul>
<li><code>payload</code> {Buffer} The <code>PING</code> frame 8-byte payload</li>
</ul>
<p>The <code>'ping'</code> event is emitted whenever a <code>PING</code> frame is received from the
connected peer.</p>
<h4 id="event-remotesettings">Event: <code>'remoteSettings'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object} A copy of the <code>SETTINGS</code> frame received.</li>
</ul>
<p>The <code>'remoteSettings'</code> event is emitted when a new <code>SETTINGS</code> frame is received
from the connected peer.</p>
<pre><code class="language-js"><div>session.on(<span class="hljs-string">&#x27;remoteSettings&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
  <span class="hljs-comment">/* Use the new settings */</span>
});
</div></code></pre>
<h4 id="event-stream">Event: <code>'stream'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>stream</code> {Http2Stream} A reference to the stream</li>
<li><code>headers</code> {HTTP/2 Headers Object} An object describing the headers</li>
<li><code>flags</code> {number} The associated numeric flags</li>
<li><code>rawHeaders</code> {Array} An array containing the raw header names followed by
their respective values.</li>
</ul>
<p>The <code>'stream'</code> event is emitted when a new <code>Http2Stream</code> is created.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
session.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers, flags</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> method = headers[<span class="hljs-string">&#x27;:method&#x27;</span>];
  <span class="hljs-keyword">const</span> path = headers[<span class="hljs-string">&#x27;:path&#x27;</span>];
  <span class="hljs-comment">// ...</span>
  stream.respond({
    <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>,
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>
  });
  stream.write(<span class="hljs-string">&#x27;hello &#x27;</span>);
  stream.end(<span class="hljs-string">&#x27;world&#x27;</span>);
});
</div></code></pre>
<p>On the server side, user code will typically not listen for this event directly,
and would instead register a handler for the <code>'stream'</code> event emitted by the
<code>net.Server</code> or <code>tls.Server</code> instances returned by <code>http2.createServer()</code> and
<code>http2.createSecureServer()</code>, respectively, as in the example below:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-comment">// Create an unencrypted HTTP/2 server</span>
<span class="hljs-keyword">const</span> server = http2.createServer();

server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  stream.respond({
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>,
    <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>
  });
  stream.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(error));
  stream.end(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);
});

server.listen(<span class="hljs-number">80</span>);
</div></code></pre>
<p>Even though HTTP/2 streams and network sockets are not in a 1:1 correspondence,
a network error will destroy each individual stream and must be handled on the
stream level, as shown above.</p>
<h4 id="event-timeout">Event: <code>'timeout'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>After the <code>http2session.setTimeout()</code> method is used to set the timeout period
for this <code>Http2Session</code>, the <code>'timeout'</code> event is emitted if there is no
activity on the <code>Http2Session</code> after the configured number of milliseconds.
Its listener does not expect any arguments.</p>
<pre><code class="language-js"><div>session.setTimeout(<span class="hljs-number">2000</span>);
session.on(<span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* .. */</span> });
</div></code></pre>
<h4 id="http2sessionalpnprotocol"><code>http2session.alpnProtocol</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{string|undefined}</li>
</ul>
<p>Value will be <code>undefined</code> if the <code>Http2Session</code> is not yet connected to a
socket, <code>h2c</code> if the <code>Http2Session</code> is not connected to a <code>TLSSocket</code>, or
will return the value of the connected <code>TLSSocket</code>'s own <code>alpnProtocol</code>
property.</p>
<h4 id="http2sessionclosecallback"><code>http2session.close([callback])</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li><code>callback</code> {Function}</li>
</ul>
<p>Gracefully closes the <code>Http2Session</code>, allowing any existing streams to
complete on their own and preventing new <code>Http2Stream</code> instances from being
created. Once closed, <code>http2session.destroy()</code> <em>might</em> be called if there
are no open <code>Http2Stream</code> instances.</p>
<p>If specified, the <code>callback</code> function is registered as a handler for the
<code>'close'</code> event.</p>
<h4 id="http2sessionclosed"><code>http2session.closed</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Will be <code>true</code> if this <code>Http2Session</code> instance has been closed, otherwise
<code>false</code>.</p>
<h4 id="http2sessionconnecting"><code>http2session.connecting</code></h4>
<!-- YAML
added: v10.0.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Will be <code>true</code> if this <code>Http2Session</code> instance is still connecting, will be set
to <code>false</code> before emitting <code>connect</code> event and/or calling the <code>http2.connect</code>
callback.</p>
<h4 id="http2sessiondestroyerror"><code>http2session.destroy([error][, code])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>error</code> {Error} An <code>Error</code> object if the <code>Http2Session</code> is being destroyed
due to an error.</li>
<li><code>code</code> {number} The HTTP/2 error code to send in the final <code>GOAWAY</code> frame.
If unspecified, and <code>error</code> is not undefined, the default is <code>INTERNAL_ERROR</code>,
otherwise defaults to <code>NO_ERROR</code>.</li>
</ul>
<p>Immediately terminates the <code>Http2Session</code> and the associated <code>net.Socket</code> or
<code>tls.TLSSocket</code>.</p>
<p>Once destroyed, the <code>Http2Session</code> will emit the <code>'close'</code> event. If <code>error</code>
is not undefined, an <code>'error'</code> event will be emitted immediately before the
<code>'close'</code> event.</p>
<p>If there are any remaining open <code>Http2Streams</code> associated with the
<code>Http2Session</code>, those will also be destroyed.</p>
<h4 id="http2sessiondestroyed"><code>http2session.destroyed</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Will be <code>true</code> if this <code>Http2Session</code> instance has been destroyed and must no
longer be used, otherwise <code>false</code>.</p>
<h4 id="http2sessionencrypted"><code>http2session.encrypted</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{boolean|undefined}</li>
</ul>
<p>Value is <code>undefined</code> if the <code>Http2Session</code> session socket has not yet been
connected, <code>true</code> if the <code>Http2Session</code> is connected with a <code>TLSSocket</code>,
and <code>false</code> if the <code>Http2Session</code> is connected to any other kind of socket
or stream.</p>
<h4 id="http2sessiongoawaycode-laststreamid-opaquedata"><code>http2session.goaway([code[, lastStreamID[, opaqueData]]])</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li><code>code</code> {number} An HTTP/2 error code</li>
<li><code>lastStreamID</code> {number} The numeric ID of the last processed <code>Http2Stream</code></li>
<li><code>opaqueData</code> {Buffer|TypedArray|DataView} A <code>TypedArray</code> or <code>DataView</code>
instance containing additional data to be carried within the <code>GOAWAY</code> frame.</li>
</ul>
<p>Transmits a <code>GOAWAY</code> frame to the connected peer <em>without</em> shutting down the
<code>Http2Session</code>.</p>
<h4 id="http2sessionlocalsettings"><code>http2session.localSettings</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{HTTP/2 Settings Object}</li>
</ul>
<p>A prototype-less object describing the current local settings of this
<code>Http2Session</code>. The local settings are local to <em>this</em> <code>Http2Session</code> instance.</p>
<h4 id="http2sessionoriginset"><code>http2session.originSet</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{string[]|undefined}</li>
</ul>
<p>If the <code>Http2Session</code> is connected to a <code>TLSSocket</code>, the <code>originSet</code> property
will return an <code>Array</code> of origins for which the <code>Http2Session</code> may be
considered authoritative.</p>
<p>The <code>originSet</code> property is only available when using a secure TLS connection.</p>
<h4 id="http2sessionpendingsettingsack"><code>http2session.pendingSettingsAck</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Indicates whether the <code>Http2Session</code> is currently waiting for acknowledgment of
a sent <code>SETTINGS</code> frame. Will be <code>true</code> after calling the
<code>http2session.settings()</code> method. Will be <code>false</code> once all sent <code>SETTINGS</code>
frames have been acknowledged.</p>
<h4 id="http2sessionpingpayload-callback"><code>http2session.ping([payload, ]callback)</code></h4>
<!-- YAML
added: v8.9.3
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>payload</code> {Buffer|TypedArray|DataView} Optional ping payload.</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {boolean}</li>
</ul>
<p>Sends a <code>PING</code> frame to the connected HTTP/2 peer. A <code>callback</code> function must
be provided. The method will return <code>true</code> if the <code>PING</code> was sent, <code>false</code>
otherwise.</p>
<p>The maximum number of outstanding (unacknowledged) pings is determined by the
<code>maxOutstandingPings</code> configuration option. The default maximum is 10.</p>
<p>If provided, the <code>payload</code> must be a <code>Buffer</code>, <code>TypedArray</code>, or <code>DataView</code>
containing 8 bytes of data that will be transmitted with the <code>PING</code> and
returned with the ping acknowledgment.</p>
<p>The callback will be invoked with three arguments: an error argument that will
be <code>null</code> if the <code>PING</code> was successfully acknowledged, a <code>duration</code> argument
that reports the number of milliseconds elapsed since the ping was sent and the
acknowledgment was received, and a <code>Buffer</code> containing the 8-byte <code>PING</code>
payload.</p>
<pre><code class="language-js"><div>session.ping(Buffer.from(<span class="hljs-string">&#x27;abcdefgh&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">err, duration, payload</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!err) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Ping acknowledged in <span class="hljs-subst">${duration}</span> milliseconds`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`With payload &#x27;<span class="hljs-subst">${payload.toString()}</span>&#x27;`</span>);
  }
});
</div></code></pre>
<p>If the <code>payload</code> argument is not specified, the default payload will be the
64-bit timestamp (little endian) marking the start of the <code>PING</code> duration.</p>
<h4 id="http2sessionref"><code>http2session.ref()</code></h4>
<!-- YAML
added: v9.4.0
-->
<p>Calls <a href="net.md#socketref"><code>ref()</code></a> on this <code>Http2Session</code>
instance's underlying <a href="net.md#class-netsocket"><code>net.Socket</code></a>.</p>
<h4 id="http2sessionremotesettings"><code>http2session.remoteSettings</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{HTTP/2 Settings Object}</li>
</ul>
<p>A prototype-less object describing the current remote settings of this
<code>Http2Session</code>. The remote settings are set by the <em>connected</em> HTTP/2 peer.</p>
<h4 id="http2sessionsetlocalwindowsizewindowsize"><code>http2session.setLocalWindowSize(windowSize)</code></h4>
<!-- YAML
added:
  - v15.3.0
  - v14.18.0
-->
<ul>
<li><code>windowSize</code> {number}</li>
</ul>
<p>Sets the local endpoint's window size.
The <code>windowSize</code> is the total window size to set, not
the delta.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-keyword">const</span> server = http2.createServer();
<span class="hljs-keyword">const</span> expectedWindowSize = <span class="hljs-number">2</span> ** <span class="hljs-number">20</span>;
server.on(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">session</span>) =&gt;</span> {

  <span class="hljs-comment">// Set local window size to be 2 ** 20</span>
  session.setLocalWindowSize(expectedWindowSize);
});
</div></code></pre>
<h4 id="http2sessionsettimeoutmsecs-callback"><code>http2session.setTimeout(msecs, callback)</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>msecs</code> {number}</li>
<li><code>callback</code> {Function}</li>
</ul>
<p>Used to set a callback function that is called when there is no activity on
the <code>Http2Session</code> after <code>msecs</code> milliseconds. The given <code>callback</code> is
registered as a listener on the <code>'timeout'</code> event.</p>
<h4 id="http2sessionsocket"><code>http2session.socket</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{net.Socket|tls.TLSSocket}</li>
</ul>
<p>Returns a <code>Proxy</code> object that acts as a <code>net.Socket</code> (or <code>tls.TLSSocket</code>) but
limits available methods to ones safe to use with HTTP/2.</p>
<p><code>destroy</code>, <code>emit</code>, <code>end</code>, <code>pause</code>, <code>read</code>, <code>resume</code>, and <code>write</code> will throw
an error with code <code>ERR_HTTP2_NO_SOCKET_MANIPULATION</code>. See
<a href="#http2session-and-sockets"><code>Http2Session</code> and Sockets</a> for more information.</p>
<p><code>setTimeout</code> method will be called on this <code>Http2Session</code>.</p>
<p>All other interactions will be routed directly to the socket.</p>
<h4 id="http2sessionstate"><code>http2session.state</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Provides miscellaneous information about the current state of the
<code>Http2Session</code>.</p>
<ul>
<li>{Object}
<ul>
<li><code>effectiveLocalWindowSize</code> {number} The current local (receive)
flow control window size for the <code>Http2Session</code>.</li>
<li><code>effectiveRecvDataLength</code> {number} The current number of bytes
that have been received since the last flow control <code>WINDOW_UPDATE</code>.</li>
<li><code>nextStreamID</code> {number} The numeric identifier to be used the
next time a new <code>Http2Stream</code> is created by this <code>Http2Session</code>.</li>
<li><code>localWindowSize</code> {number} The number of bytes that the remote peer can
send without receiving a <code>WINDOW_UPDATE</code>.</li>
<li><code>lastProcStreamID</code> {number} The numeric id of the <code>Http2Stream</code>
for which a <code>HEADERS</code> or <code>DATA</code> frame was most recently received.</li>
<li><code>remoteWindowSize</code> {number} The number of bytes that this <code>Http2Session</code>
may send without receiving a <code>WINDOW_UPDATE</code>.</li>
<li><code>outboundQueueSize</code> {number} The number of frames currently within the
outbound queue for this <code>Http2Session</code>.</li>
<li><code>deflateDynamicTableSize</code> {number} The current size in bytes of the
outbound header compression state table.</li>
<li><code>inflateDynamicTableSize</code> {number} The current size in bytes of the
inbound header compression state table.</li>
</ul>
</li>
</ul>
<p>An object describing the current status of this <code>Http2Session</code>.</p>
<h4 id="http2sessionsettingssettings"><code>http2session.settings([settings][, callback])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object}</li>
<li><code>callback</code> {Function} Callback that is called once the session is connected or
right away if the session is already connected.
<ul>
<li><code>err</code> {Error|null}</li>
<li><code>settings</code> {HTTP/2 Settings Object} The updated <code>settings</code> object.</li>
<li><code>duration</code> {integer}</li>
</ul>
</li>
</ul>
<p>Updates the current local settings for this <code>Http2Session</code> and sends a new
<code>SETTINGS</code> frame to the connected HTTP/2 peer.</p>
<p>Once called, the <code>http2session.pendingSettingsAck</code> property will be <code>true</code>
while the session is waiting for the remote peer to acknowledge the new
settings.</p>
<p>The new settings will not become effective until the <code>SETTINGS</code> acknowledgment
is received and the <code>'localSettings'</code> event is emitted. It is possible to send
multiple <code>SETTINGS</code> frames while acknowledgment is still pending.</p>
<h4 id="http2sessiontype"><code>http2session.type</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{number}</li>
</ul>
<p>The <code>http2session.type</code> will be equal to
<code>http2.constants.NGHTTP2_SESSION_SERVER</code> if this <code>Http2Session</code> instance is a
server, and <code>http2.constants.NGHTTP2_SESSION_CLIENT</code> if the instance is a
client.</p>
<h4 id="http2sessionunref"><code>http2session.unref()</code></h4>
<!-- YAML
added: v9.4.0
-->
<p>Calls <a href="net.md#socketunref"><code>unref()</code></a> on this <code>Http2Session</code>
instance's underlying <a href="net.md#class-netsocket"><code>net.Socket</code></a>.</p>
<h3 id="class-serverhttp2session">Class: <code>ServerHttp2Session</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {Http2Session}</li>
</ul>
<h4 id="serverhttp2sessionaltsvcalt-originorstream"><code>serverhttp2session.altsvc(alt, originOrStream)</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li><code>alt</code> {string} A description of the alternative service configuration as
defined by <a href="https://tools.ietf.org/html/rfc7838">RFC 7838</a>.</li>
<li><code>originOrStream</code> {number|string|URL|Object} Either a URL string specifying
the origin (or an <code>Object</code> with an <code>origin</code> property) or the numeric
identifier of an active <code>Http2Stream</code> as given by the <code>http2stream.id</code>
property.</li>
</ul>
<p>Submits an <code>ALTSVC</code> frame (as defined by <a href="https://tools.ietf.org/html/rfc7838">RFC 7838</a>) to the connected client.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;session&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">session</span>) =&gt;</span> {
  <span class="hljs-comment">// Set altsvc for origin https://example.org:80</span>
  session.altsvc(<span class="hljs-string">&#x27;h2=&quot;:8000&quot;&#x27;</span>, <span class="hljs-string">&#x27;https://example.org:80&#x27;</span>);
});

server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-comment">// Set altsvc for a specific stream</span>
  stream.session.altsvc(<span class="hljs-string">&#x27;h2=&quot;:8000&quot;&#x27;</span>, stream.id);
});
</div></code></pre>
<p>Sending an <code>ALTSVC</code> frame with a specific stream ID indicates that the alternate
service is associated with the origin of the given <code>Http2Stream</code>.</p>
<p>The <code>alt</code> and origin string <em>must</em> contain only ASCII bytes and are
strictly interpreted as a sequence of ASCII bytes. The special value <code>'clear'</code>
may be passed to clear any previously set alternative service for a given
domain.</p>
<p>When a string is passed for the <code>originOrStream</code> argument, it will be parsed as
a URL and the origin will be derived. For instance, the origin for the
HTTP URL <code>'https://example.org/foo/bar'</code> is the ASCII string
<code>'https://example.org'</code>. An error will be thrown if either the given string
cannot be parsed as a URL or if a valid origin cannot be derived.</p>
<p>A <code>URL</code> object, or any object with an <code>origin</code> property, may be passed as
<code>originOrStream</code>, in which case the value of the <code>origin</code> property will be
used. The value of the <code>origin</code> property <em>must</em> be a properly serialized
ASCII origin.</p>
<h4 id="specifying-alternative-services">Specifying alternative services</h4>
<p>The format of the <code>alt</code> parameter is strictly defined by <a href="https://tools.ietf.org/html/rfc7838">RFC 7838</a> as an
ASCII string containing a comma-delimited list of &quot;alternative&quot; protocols
associated with a specific host and port.</p>
<p>For example, the value <code>'h2=&quot;example.org:81&quot;'</code> indicates that the HTTP/2
protocol is available on the host <code>'example.org'</code> on TCP/IP port 81. The
host and port <em>must</em> be contained within the quote (<code>&quot;</code>) characters.</p>
<p>Multiple alternatives may be specified, for instance: <code>'h2=&quot;example.org:81&quot;, h2=&quot;:82&quot;'</code>.</p>
<p>The protocol identifier (<code>'h2'</code> in the examples) may be any valid
<a href="https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids">ALPN Protocol ID</a>.</p>
<p>The syntax of these values is not validated by the Node.js implementation and
are passed through as provided by the user or received from the peer.</p>
<h4 id="serverhttp2sessionoriginorigins"><code>serverhttp2session.origin(...origins)</code></h4>
<!-- YAML
added: v10.12.0
-->
<ul>
<li><code>origins</code> { string | URL | Object } One or more URL Strings passed as
separate arguments.</li>
</ul>
<p>Submits an <code>ORIGIN</code> frame (as defined by <a href="https://tools.ietf.org/html/rfc8336">RFC 8336</a>) to the connected client
to advertise the set of origins for which the server is capable of providing
authoritative responses.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> options = getSecureOptionsSomehow();
<span class="hljs-keyword">const</span> server = http2.createSecureServer(options);
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond();
  stream.end(<span class="hljs-string">&#x27;ok&#x27;</span>);
});
server.on(<span class="hljs-string">&#x27;session&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">session</span>) =&gt;</span> {
  session.origin(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, <span class="hljs-string">&#x27;https://example.org&#x27;</span>);
});
</div></code></pre>
<p>When a string is passed as an <code>origin</code>, it will be parsed as a URL and the
origin will be derived. For instance, the origin for the HTTP URL
<code>'https://example.org/foo/bar'</code> is the ASCII string
<code>'https://example.org'</code>. An error will be thrown if either the given string
cannot be parsed as a URL or if a valid origin cannot be derived.</p>
<p>A <code>URL</code> object, or any object with an <code>origin</code> property, may be passed as
an <code>origin</code>, in which case the value of the <code>origin</code> property will be
used. The value of the <code>origin</code> property <em>must</em> be a properly serialized
ASCII origin.</p>
<p>Alternatively, the <code>origins</code> option may be used when creating a new HTTP/2
server using the <code>http2.createSecureServer()</code> method:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> options = getSecureOptionsSomehow();
options.origins = [<span class="hljs-string">&#x27;https://example.com&#x27;</span>, <span class="hljs-string">&#x27;https://example.org&#x27;</span>];
<span class="hljs-keyword">const</span> server = http2.createSecureServer(options);
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond();
  stream.end(<span class="hljs-string">&#x27;ok&#x27;</span>);
});
</div></code></pre>
<h3 id="class-clienthttp2session">Class: <code>ClientHttp2Session</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {Http2Session}</li>
</ul>
<h4 id="event-altsvc">Event: <code>'altsvc'</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li><code>alt</code> {string}</li>
<li><code>origin</code> {string}</li>
<li><code>streamId</code> {number}</li>
</ul>
<p>The <code>'altsvc'</code> event is emitted whenever an <code>ALTSVC</code> frame is received by
the client. The event is emitted with the <code>ALTSVC</code> value, origin, and stream
ID. If no <code>origin</code> is provided in the <code>ALTSVC</code> frame, <code>origin</code> will
be an empty string.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;https://example.org&#x27;</span>);

client.on(<span class="hljs-string">&#x27;altsvc&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">alt, origin, streamId</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(alt);
  <span class="hljs-built_in">console</span>.log(origin);
  <span class="hljs-built_in">console</span>.log(streamId);
});
</div></code></pre>
<h4 id="event-origin">Event: <code>'origin'</code></h4>
<!-- YAML
added: v10.12.0
-->
<ul>
<li><code>origins</code> {string[]}</li>
</ul>
<p>The <code>'origin'</code> event is emitted whenever an <code>ORIGIN</code> frame is received by
the client. The event is emitted with an array of <code>origin</code> strings. The
<code>http2session.originSet</code> will be updated to include the received
origins.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;https://example.org&#x27;</span>);

client.on(<span class="hljs-string">&#x27;origin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">origins</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; origins.length; n++)
    <span class="hljs-built_in">console</span>.log(origins[n]);
});
</div></code></pre>
<p>The <code>'origin'</code> event is only emitted when using a secure TLS connection.</p>
<h4 id="clienthttp2sessionrequestheaders-options"><code>clienthttp2session.request(headers[, options])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>
<p><code>headers</code> {HTTP/2 Headers Object}</p>
</li>
<li>
<p><code>options</code> {Object}</p>
<ul>
<li><code>endStream</code> {boolean} <code>true</code> if the <code>Http2Stream</code> <em>writable</em> side should
be closed initially, such as when sending a <code>GET</code> request that should not
expect a payload body.</li>
<li><code>exclusive</code> {boolean} When <code>true</code> and <code>parent</code> identifies a parent Stream,
the created stream is made the sole direct dependency of the parent, with
all other existing dependents made a dependent of the newly created stream.
<strong>Default:</strong> <code>false</code>.</li>
<li><code>parent</code> {number} Specifies the numeric identifier of a stream the newly
created stream is dependent on.</li>
<li><code>weight</code> {number} Specifies the relative dependency of a stream in relation
to other streams with the same <code>parent</code>. The value is a number between <code>1</code>
and <code>256</code> (inclusive).</li>
<li><code>waitForTrailers</code> {boolean} When <code>true</code>, the <code>Http2Stream</code> will emit the
<code>'wantTrailers'</code> event after the final <code>DATA</code> frame has been sent.</li>
<li><code>signal</code> {AbortSignal} An AbortSignal that may be used to abort an ongoing
request.</li>
</ul>
</li>
<li>
<p>Returns: {ClientHttp2Stream}</p>
</li>
</ul>
<p>For HTTP/2 Client <code>Http2Session</code> instances only, the <code>http2session.request()</code>
creates and returns an <code>Http2Stream</code> instance that can be used to send an
HTTP/2 request to the connected server.</p>
<p>This method is only available if <code>http2session.type</code> is equal to
<code>http2.constants.NGHTTP2_SESSION_CLIENT</code>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> clientSession = http2.connect(<span class="hljs-string">&#x27;https://localhost:1234&#x27;</span>);
<span class="hljs-keyword">const</span> {
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS
} = http2.constants;

<span class="hljs-keyword">const</span> req = clientSession.request({ [HTTP2_HEADER_PATH]: <span class="hljs-string">&#x27;/&#x27;</span> });
req.on(<span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers[HTTP2_HEADER_STATUS]);
  req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { <span class="hljs-comment">/* .. */</span> });
  req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* .. */</span> });
});
</div></code></pre>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>'wantTrailers'</code> event
is emitted immediately after queuing the last chunk of payload data to be sent.
The <code>http2stream.sendTrailers()</code> method can then be called to send trailing
headers to the peer.</p>
<p>When <code>options.waitForTrailers</code> is set, the <code>Http2Stream</code> will not automatically
close when the final <code>DATA</code> frame is transmitted. User code must call either
<code>http2stream.sendTrailers()</code> or <code>http2stream.close()</code> to close the
<code>Http2Stream</code>.</p>
<p>When <code>options.signal</code> is set with an <code>AbortSignal</code> and then <code>abort</code> on the
corresponding <code>AbortController</code> is called, the request will emit an <code>'error'</code>
event with an <code>AbortError</code> error.</p>
<p>The <code>:method</code> and <code>:path</code> pseudo-headers are not specified within <code>headers</code>,
they respectively default to:</p>
<ul>
<li><code>:method</code> = <code>'GET'</code></li>
<li><code>:path</code> = <code>/</code></li>
</ul>
<h3 id="class-http2stream">Class: <code>Http2Stream</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {stream.Duplex}</li>
</ul>
<p>Each instance of the <code>Http2Stream</code> class represents a bidirectional HTTP/2
communications stream over an <code>Http2Session</code> instance. Any single <code>Http2Session</code>
may have up to 2<sup>31</sup>-1 <code>Http2Stream</code> instances over its lifetime.</p>
<p>User code will not construct <code>Http2Stream</code> instances directly. Rather, these
are created, managed, and provided to user code through the <code>Http2Session</code>
instance. On the server, <code>Http2Stream</code> instances are created either in response
to an incoming HTTP request (and handed off to user code via the <code>'stream'</code>
event), or in response to a call to the <code>http2stream.pushStream()</code> method.
On the client, <code>Http2Stream</code> instances are created and returned when either the
<code>http2session.request()</code> method is called, or in response to an incoming
<code>'push'</code> event.</p>
<p>The <code>Http2Stream</code> class is a base for the <a href="#class-serverhttp2stream"><code>ServerHttp2Stream</code></a> and
<a href="#class-clienthttp2stream"><code>ClientHttp2Stream</code></a> classes, each of which is used specifically by either
the Server or Client side, respectively.</p>
<p>All <code>Http2Stream</code> instances are <a href="stream.md#class-streamduplex"><code>Duplex</code></a> streams. The <code>Writable</code> side of the
<code>Duplex</code> is used to send data to the connected peer, while the <code>Readable</code> side
is used to receive data sent by the connected peer.</p>
<p>The default text character encoding for all <code>Http2Stream</code>s is UTF-8. As a best
practice, it is recommended that when using an <code>Http2Stream</code> to send text,
the <code>'content-type'</code> header should be set and should identify the character
encoding used.</p>
<pre><code class="language-js"><div>stream.respond({
  <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>,
  <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>
});
</div></code></pre>
<h4 id="http2stream-lifecycle"><code>Http2Stream</code> Lifecycle</h4>
<h5 id="creation">Creation</h5>
<p>On the server side, instances of <a href="#class-serverhttp2stream"><code>ServerHttp2Stream</code></a> are created either
when:</p>
<ul>
<li>A new HTTP/2 <code>HEADERS</code> frame with a previously unused stream ID is received;</li>
<li>The <code>http2stream.pushStream()</code> method is called.</li>
</ul>
<p>On the client side, instances of <a href="#class-clienthttp2stream"><code>ClientHttp2Stream</code></a> are created when the
<code>http2session.request()</code> method is called.</p>
<p>On the client, the <code>Http2Stream</code> instance returned by <code>http2session.request()</code>
may not be immediately ready for use if the parent <code>Http2Session</code> has not yet
been fully established. In such cases, operations called on the <code>Http2Stream</code>
will be buffered until the <code>'ready'</code> event is emitted. User code should rarely,
if ever, need to handle the <code>'ready'</code> event directly. The ready status of an
<code>Http2Stream</code> can be determined by checking the value of <code>http2stream.id</code>. If
the value is <code>undefined</code>, the stream is not yet ready for use.</p>
<h5 id="destruction">Destruction</h5>
<p>All <a href="#class-http2stream"><code>Http2Stream</code></a> instances are destroyed either when:</p>
<ul>
<li>An <code>RST_STREAM</code> frame for the stream is received by the connected peer,
and (for client streams only) pending data has been read.</li>
<li>The <code>http2stream.close()</code> method is called, and (for client streams only)
pending data has been read.</li>
<li>The <code>http2stream.destroy()</code> or <code>http2session.destroy()</code> methods are called.</li>
</ul>
<p>When an <code>Http2Stream</code> instance is destroyed, an attempt will be made to send an
<code>RST_STREAM</code> frame to the connected peer.</p>
<p>When the <code>Http2Stream</code> instance is destroyed, the <code>'close'</code> event will
be emitted. Because <code>Http2Stream</code> is an instance of <code>stream.Duplex</code>, the
<code>'end'</code> event will also be emitted if the stream data is currently flowing.
The <code>'error'</code> event may also be emitted if <code>http2stream.destroy()</code> was called
with an <code>Error</code> passed as the first argument.</p>
<p>After the <code>Http2Stream</code> has been destroyed, the <code>http2stream.destroyed</code>
property will be <code>true</code> and the <code>http2stream.rstCode</code> property will specify the
<code>RST_STREAM</code> error code. The <code>Http2Stream</code> instance is no longer usable once
destroyed.</p>
<h4 id="event-aborted">Event: <code>'aborted'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'aborted'</code> event is emitted whenever a <code>Http2Stream</code> instance is
abnormally aborted in mid-communication.
Its listener does not expect any arguments.</p>
<p>The <code>'aborted'</code> event will only be emitted if the <code>Http2Stream</code> writable side
has not been ended.</p>
<h4 id="event-close-1">Event: <code>'close'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'close'</code> event is emitted when the <code>Http2Stream</code> is destroyed. Once
this event is emitted, the <code>Http2Stream</code> instance is no longer usable.</p>
<p>The HTTP/2 error code used when closing the stream can be retrieved using
the <code>http2stream.rstCode</code> property. If the code is any value other than
<code>NGHTTP2_NO_ERROR</code> (<code>0</code>), an <code>'error'</code> event will have also been emitted.</p>
<h4 id="event-error-1">Event: <code>'error'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>error</code> {Error}</li>
</ul>
<p>The <code>'error'</code> event is emitted when an error occurs during the processing of
an <code>Http2Stream</code>.</p>
<h4 id="event-frameerror-1">Event: <code>'frameError'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>type</code> {integer} The frame type.</li>
<li><code>code</code> {integer} The error code.</li>
<li><code>id</code> {integer} The stream id (or <code>0</code> if the frame isn't associated with a
stream).</li>
</ul>
<p>The <code>'frameError'</code> event is emitted when an error occurs while attempting to
send a frame. When invoked, the handler function will receive an integer
argument identifying the frame type, and an integer argument identifying the
error code. The <code>Http2Stream</code> instance will be destroyed immediately after the
<code>'frameError'</code> event is emitted.</p>
<h4 id="event-ready">Event: <code>'ready'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'ready'</code> event is emitted when the <code>Http2Stream</code> has been opened, has
been assigned an <code>id</code>, and can be used. The listener does not expect any
arguments.</p>
<h4 id="event-timeout-1">Event: <code>'timeout'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'timeout'</code> event is emitted after no activity is received for this
<code>Http2Stream</code> within the number of milliseconds set using
<code>http2stream.setTimeout()</code>.
Its listener does not expect any arguments.</p>
<h4 id="event-trailers">Event: <code>'trailers'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object} An object describing the headers</li>
<li><code>flags</code> {number} The associated numeric flags</li>
</ul>
<p>The <code>'trailers'</code> event is emitted when a block of headers associated with
trailing header fields is received. The listener callback is passed the
<a href="#headers-object">HTTP/2 Headers Object</a> and flags associated with the headers.</p>
<p>This event might not be emitted if <code>http2stream.end()</code> is called
before trailers are received and the incoming data is not being read or
listened for.</p>
<pre><code class="language-js"><div>stream.on(<span class="hljs-string">&#x27;trailers&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers, flags</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers);
});
</div></code></pre>
<h4 id="event-wanttrailers">Event: <code>'wantTrailers'</code></h4>
<!-- YAML
added: v10.0.0
-->
<p>The <code>'wantTrailers'</code> event is emitted when the <code>Http2Stream</code> has queued the
final <code>DATA</code> frame to be sent on a frame and the <code>Http2Stream</code> is ready to send
trailing headers. When initiating a request or response, the <code>waitForTrailers</code>
option must be set for this event to be emitted.</p>
<h4 id="http2streamaborted"><code>http2stream.aborted</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Set to <code>true</code> if the <code>Http2Stream</code> instance was aborted abnormally. When set,
the <code>'aborted'</code> event will have been emitted.</p>
<h4 id="http2streambuffersize"><code>http2stream.bufferSize</code></h4>
<!-- YAML
added:
 - v11.2.0
 - v10.16.0
-->
<ul>
<li>{number}</li>
</ul>
<p>This property shows the number of characters currently buffered to be written.
See <a href="net.md#socketbuffersize"><code>net.Socket.bufferSize</code></a> for details.</p>
<h4 id="http2streamclosecode-callback"><code>http2stream.close(code[, callback])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>code</code> {number} Unsigned 32-bit integer identifying the error code.
<strong>Default:</strong> <code>http2.constants.NGHTTP2_NO_ERROR</code> (<code>0x00</code>).</li>
<li><code>callback</code> {Function} An optional function registered to listen for the
<code>'close'</code> event.</li>
</ul>
<p>Closes the <code>Http2Stream</code> instance by sending an <code>RST_STREAM</code> frame to the
connected HTTP/2 peer.</p>
<h4 id="http2streamclosed"><code>http2stream.closed</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Set to <code>true</code> if the <code>Http2Stream</code> instance has been closed.</p>
<h4 id="http2streamdestroyed"><code>http2stream.destroyed</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Set to <code>true</code> if the <code>Http2Stream</code> instance has been destroyed and is no longer
usable.</p>
<h4 id="http2streamendafterheaders"><code>http2stream.endAfterHeaders</code></h4>
<!-- YAML
added: v10.11.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Set to <code>true</code> if the <code>END_STREAM</code> flag was set in the request or response
HEADERS frame received, indicating that no additional data should be received
and the readable side of the <code>Http2Stream</code> will be closed.</p>
<h4 id="http2streamid"><code>http2stream.id</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{number|undefined}</li>
</ul>
<p>The numeric stream identifier of this <code>Http2Stream</code> instance. Set to <code>undefined</code>
if the stream identifier has not yet been assigned.</p>
<h4 id="http2streampending"><code>http2stream.pending</code></h4>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Set to <code>true</code> if the <code>Http2Stream</code> instance has not yet been assigned a
numeric stream identifier.</p>
<h4 id="http2streampriorityoptions"><code>http2stream.priority(options)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>exclusive</code> {boolean} When <code>true</code> and <code>parent</code> identifies a parent Stream,
this stream is made the sole direct dependency of the parent, with
all other existing dependents made a dependent of this stream. <strong>Default:</strong>
<code>false</code>.</li>
<li><code>parent</code> {number} Specifies the numeric identifier of a stream this stream
is dependent on.</li>
<li><code>weight</code> {number} Specifies the relative dependency of a stream in relation
to other streams with the same <code>parent</code>. The value is a number between <code>1</code>
and <code>256</code> (inclusive).</li>
<li><code>silent</code> {boolean} When <code>true</code>, changes the priority locally without
sending a <code>PRIORITY</code> frame to the connected peer.</li>
</ul>
</li>
</ul>
<p>Updates the priority for this <code>Http2Stream</code> instance.</p>
<h4 id="http2streamrstcode"><code>http2stream.rstCode</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{number}</li>
</ul>
<p>Set to the <code>RST_STREAM</code> <a href="#error-codes-for-rst_stream-and-goaway">error code</a> reported when the <code>Http2Stream</code> is
destroyed after either receiving an <code>RST_STREAM</code> frame from the connected peer,
calling <code>http2stream.close()</code>, or <code>http2stream.destroy()</code>. Will be
<code>undefined</code> if the <code>Http2Stream</code> has not been closed.</p>
<h4 id="http2streamsentheaders"><code>http2stream.sentHeaders</code></h4>
<!-- YAML
added: v9.5.0
-->
<ul>
<li>{HTTP/2 Headers Object}</li>
</ul>
<p>An object containing the outbound headers sent for this <code>Http2Stream</code>.</p>
<h4 id="http2streamsentinfoheaders"><code>http2stream.sentInfoHeaders</code></h4>
<!-- YAML
added: v9.5.0
-->
<ul>
<li>{HTTP/2 Headers Object[]}</li>
</ul>
<p>An array of objects containing the outbound informational (additional) headers
sent for this <code>Http2Stream</code>.</p>
<h4 id="http2streamsenttrailers"><code>http2stream.sentTrailers</code></h4>
<!-- YAML
added: v9.5.0
-->
<ul>
<li>{HTTP/2 Headers Object}</li>
</ul>
<p>An object containing the outbound trailers sent for this <code>HttpStream</code>.</p>
<h4 id="http2streamsession"><code>http2stream.session</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{Http2Session}</li>
</ul>
<p>A reference to the <code>Http2Session</code> instance that owns this <code>Http2Stream</code>. The
value will be <code>undefined</code> after the <code>Http2Stream</code> instance is destroyed.</p>
<h4 id="http2streamsettimeoutmsecs-callback"><code>http2stream.setTimeout(msecs, callback)</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>msecs</code> {number}</li>
<li><code>callback</code> {Function}</li>
</ul>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;http://example.org:8000&#x27;</span>);
<span class="hljs-keyword">const</span> { NGHTTP2_CANCEL } = http2.constants;
<span class="hljs-keyword">const</span> req = client.request({ <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span> });

<span class="hljs-comment">// Cancel the stream if there&#x27;s no activity after 5 seconds</span>
req.setTimeout(<span class="hljs-number">5000</span>, <span class="hljs-function">() =&gt;</span> req.close(NGHTTP2_CANCEL));
</div></code></pre>
<h4 id="http2streamstate"><code>http2stream.state</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Provides miscellaneous information about the current state of the
<code>Http2Stream</code>.</p>
<ul>
<li>{Object}
<ul>
<li><code>localWindowSize</code> {number} The number of bytes the connected peer may send
for this <code>Http2Stream</code> without receiving a <code>WINDOW_UPDATE</code>.</li>
<li><code>state</code> {number} A flag indicating the low-level current state of the
<code>Http2Stream</code> as determined by <code>nghttp2</code>.</li>
<li><code>localClose</code> {number} <code>1</code> if this <code>Http2Stream</code> has been closed locally.</li>
<li><code>remoteClose</code> {number} <code>1</code> if this <code>Http2Stream</code> has been closed
remotely.</li>
<li><code>sumDependencyWeight</code> {number} The sum weight of all <code>Http2Stream</code>
instances that depend on this <code>Http2Stream</code> as specified using
<code>PRIORITY</code> frames.</li>
<li><code>weight</code> {number} The priority weight of this <code>Http2Stream</code>.</li>
</ul>
</li>
</ul>
<p>A current state of this <code>Http2Stream</code>.</p>
<h4 id="http2streamsendtrailersheaders"><code>http2stream.sendTrailers(headers)</code></h4>
<!-- YAML
added: v10.0.0
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
</ul>
<p>Sends a trailing <code>HEADERS</code> frame to the connected HTTP/2 peer. This method
will cause the <code>Http2Stream</code> to be immediately closed and must only be
called after the <code>'wantTrailers'</code> event has been emitted. When sending a
request or sending a response, the <code>options.waitForTrailers</code> option must be set
in order to keep the <code>Http2Stream</code> open after the final <code>DATA</code> frame so that
trailers can be sent.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond(<span class="hljs-literal">undefined</span>, { <span class="hljs-attr">waitForTrailers</span>: <span class="hljs-literal">true</span> });
  stream.on(<span class="hljs-string">&#x27;wantTrailers&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    stream.sendTrailers({ <span class="hljs-attr">xyz</span>: <span class="hljs-string">&#x27;abc&#x27;</span> });
  });
  stream.end(<span class="hljs-string">&#x27;Hello World&#x27;</span>);
});
</div></code></pre>
<p>The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
fields (e.g. <code>':method'</code>, <code>':path'</code>, etc).</p>
<h3 id="class-clienthttp2stream">Class: <code>ClientHttp2Stream</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends {Http2Stream}</li>
</ul>
<p>The <code>ClientHttp2Stream</code> class is an extension of <code>Http2Stream</code> that is
used exclusively on HTTP/2 Clients. <code>Http2Stream</code> instances on the client
provide events such as <code>'response'</code> and <code>'push'</code> that are only relevant on
the client.</p>
<h4 id="event-continue">Event: <code>'continue'</code></h4>
<!-- YAML
added: v8.5.0
-->
<p>Emitted when the server sends a <code>100 Continue</code> status, usually because
the request contained <code>Expect: 100-continue</code>. This is an instruction that
the client should send the request body.</p>
<h4 id="event-headers">Event: <code>'headers'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'headers'</code> event is emitted when an additional block of headers is received
for a stream, such as when a block of <code>1xx</code> informational headers is received.
The listener callback is passed the <a href="#headers-object">HTTP/2 Headers Object</a> and flags
associated with the headers.</p>
<pre><code class="language-js"><div>stream.on(<span class="hljs-string">&#x27;headers&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers, flags</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers);
});
</div></code></pre>
<h4 id="event-push">Event: <code>'push'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'push'</code> event is emitted when response headers for a Server Push stream
are received. The listener callback is passed the <a href="#headers-object">HTTP/2 Headers Object</a> and
flags associated with the headers.</p>
<pre><code class="language-js"><div>stream.on(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers, flags</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers);
});
</div></code></pre>
<h4 id="event-response">Event: <code>'response'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'response'</code> event is emitted when a response <code>HEADERS</code> frame has been
received for this stream from the connected HTTP/2 server. The listener is
invoked with two arguments: an <code>Object</code> containing the received
<a href="#headers-object">HTTP/2 Headers Object</a>, and flags associated with the headers.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;https://localhost&#x27;</span>);
<span class="hljs-keyword">const</span> req = client.request({ <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span> });
req.on(<span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers, flags</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers[<span class="hljs-string">&#x27;:status&#x27;</span>]);
});
</div></code></pre>
<h3 id="class-serverhttp2stream">Class: <code>ServerHttp2Stream</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {Http2Stream}</li>
</ul>
<p>The <code>ServerHttp2Stream</code> class is an extension of <a href="#class-http2stream"><code>Http2Stream</code></a> that is
used exclusively on HTTP/2 Servers. <code>Http2Stream</code> instances on the server
provide additional methods such as <code>http2stream.pushStream()</code> and
<code>http2stream.respond()</code> that are only relevant on the server.</p>
<h4 id="http2streamadditionalheadersheaders"><code>http2stream.additionalHeaders(headers)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
</ul>
<p>Sends an additional informational <code>HEADERS</code> frame to the connected HTTP/2 peer.</p>
<h4 id="http2streamheaderssent"><code>http2stream.headersSent</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>True if headers were sent, false otherwise (read-only).</p>
<h4 id="http2streampushallowed"><code>http2stream.pushAllowed</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Read-only property mapped to the <code>SETTINGS_ENABLE_PUSH</code> flag of the remote
client's most recent <code>SETTINGS</code> frame. Will be <code>true</code> if the remote peer
accepts push streams, <code>false</code> otherwise. Settings are the same for every
<code>Http2Stream</code> in the same <code>Http2Session</code>.</p>
<h4 id="http2streampushstreamheaders-options-callback"><code>http2stream.pushStream(headers[, options], callback)</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
<li><code>options</code> {Object}
<ul>
<li><code>exclusive</code> {boolean} When <code>true</code> and <code>parent</code> identifies a parent Stream,
the created stream is made the sole direct dependency of the parent, with
all other existing dependents made a dependent of the newly created stream.
<strong>Default:</strong> <code>false</code>.</li>
<li><code>parent</code> {number} Specifies the numeric identifier of a stream the newly
created stream is dependent on.</li>
</ul>
</li>
<li><code>callback</code> {Function} Callback that is called once the push stream has been
initiated.
<ul>
<li><code>err</code> {Error}</li>
<li><code>pushStream</code> {ServerHttp2Stream} The returned <code>pushStream</code> object.</li>
<li><code>headers</code> {HTTP/2 Headers Object} Headers object the <code>pushStream</code> was
initiated with.</li>
</ul>
</li>
</ul>
<p>Initiates a push stream. The callback is invoked with the new <code>Http2Stream</code>
instance created for the push stream passed as the second argument, or an
<code>Error</code> passed as the first argument.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span> });
  stream.pushStream({ <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span> }, <span class="hljs-function">(<span class="hljs-params">err, pushStream, headers</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    pushStream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span> });
    pushStream.end(<span class="hljs-string">&#x27;some pushed data&#x27;</span>);
  });
  stream.end(<span class="hljs-string">&#x27;some data&#x27;</span>);
});
</div></code></pre>
<p>Setting the weight of a push stream is not allowed in the <code>HEADERS</code> frame. Pass
a <code>weight</code> value to <code>http2stream.priority</code> with the <code>silent</code> option set to
<code>true</code> to enable server-side bandwidth balancing between concurrent streams.</p>
<p>Calling <code>http2stream.pushStream()</code> from within a pushed stream is not permitted
and will throw an error.</p>
<h4 id="http2streamrespondheaders-options"><code>http2stream.respond([headers[, options]])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version:
    - v14.5.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/33160
    description: Allow explicitly setting date headers.
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
<li><code>options</code> {Object}
<ul>
<li><code>endStream</code> {boolean} Set to <code>true</code> to indicate that the response will not
include payload data.</li>
<li><code>waitForTrailers</code> {boolean} When <code>true</code>, the <code>Http2Stream</code> will emit the
<code>'wantTrailers'</code> event after the final <code>DATA</code> frame has been sent.</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span> });
  stream.end(<span class="hljs-string">&#x27;some data&#x27;</span>);
});
</div></code></pre>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>'wantTrailers'</code> event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The <code>http2stream.sendTrailers()</code> method can then be used to sent trailing
header fields to the peer.</p>
<p>When <code>options.waitForTrailers</code> is set, the <code>Http2Stream</code> will not automatically
close when the final <code>DATA</code> frame is transmitted. User code must call either
<code>http2stream.sendTrailers()</code> or <code>http2stream.close()</code> to close the
<code>Http2Stream</code>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span> }, { <span class="hljs-attr">waitForTrailers</span>: <span class="hljs-literal">true</span> });
  stream.on(<span class="hljs-string">&#x27;wantTrailers&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    stream.sendTrailers({ <span class="hljs-attr">ABC</span>: <span class="hljs-string">&#x27;some value to send&#x27;</span> });
  });
  stream.end(<span class="hljs-string">&#x27;some data&#x27;</span>);
});
</div></code></pre>
<h4 id="http2streamrespondwithfdfd-headers-options"><code>http2stream.respondWithFD(fd[, headers[, options]])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version:
    - v14.5.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/33160
    description: Allow explicitly setting date headers.
  - version: v12.12.0
    pr-url: https://github.com/nodejs/node/pull/29876
    description: The `fd` option may now be a `FileHandle`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18936
    description: Any readable file descriptor, not necessarily for a
                 regular file, is supported now.
-->
<ul>
<li><code>fd</code> {number|FileHandle} A readable file descriptor.</li>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
<li><code>options</code> {Object}
<ul>
<li><code>statCheck</code> {Function}</li>
<li><code>waitForTrailers</code> {boolean} When <code>true</code>, the <code>Http2Stream</code> will emit the
<code>'wantTrailers'</code> event after the final <code>DATA</code> frame has been sent.</li>
<li><code>offset</code> {number} The offset position at which to begin reading.</li>
<li><code>length</code> {number} The amount of data from the fd to send.</li>
</ul>
</li>
</ul>
<p>Initiates a response whose data is read from the given file descriptor. No
validation is performed on the given file descriptor. If an error occurs while
attempting to read data using the file descriptor, the <code>Http2Stream</code> will be
closed using an <code>RST_STREAM</code> frame using the standard <code>INTERNAL_ERROR</code> code.</p>
<p>When used, the <code>Http2Stream</code> object's <code>Duplex</code> interface will be closed
automatically.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> fd = fs.openSync(<span class="hljs-string">&#x27;/some/file&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);

  <span class="hljs-keyword">const</span> stat = fs.fstatSync(fd);
  <span class="hljs-keyword">const</span> headers = {
    <span class="hljs-string">&#x27;content-length&#x27;</span>: stat.size,
    <span class="hljs-string">&#x27;last-modified&#x27;</span>: stat.mtime.toUTCString(),
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>
  };
  stream.respondWithFD(fd, headers);
  stream.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> fs.closeSync(fd));
});
</div></code></pre>
<p>The optional <code>options.statCheck</code> function may be specified to give user code
an opportunity to set additional content headers based on the <code>fs.Stat</code> details
of the given fd. If the <code>statCheck</code> function is provided, the
<code>http2stream.respondWithFD()</code> method will perform an <code>fs.fstat()</code> call to
collect details on the provided file descriptor.</p>
<p>The <code>offset</code> and <code>length</code> options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.</p>
<p>The file descriptor or <code>FileHandle</code> is not closed when the stream is closed,
so it will need to be closed manually once it is no longer needed.
Using the same file descriptor concurrently for multiple streams
is not supported and may result in data loss. Re-using a file descriptor
after a stream has finished is supported.</p>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>'wantTrailers'</code> event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The <code>http2stream.sendTrailers()</code> method can then be used to sent trailing
header fields to the peer.</p>
<p>When <code>options.waitForTrailers</code> is set, the <code>Http2Stream</code> will not automatically
close when the final <code>DATA</code> frame is transmitted. User code <em>must</em> call either
<code>http2stream.sendTrailers()</code> or <code>http2stream.close()</code> to close the
<code>Http2Stream</code>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> fd = fs.openSync(<span class="hljs-string">&#x27;/some/file&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);

  <span class="hljs-keyword">const</span> stat = fs.fstatSync(fd);
  <span class="hljs-keyword">const</span> headers = {
    <span class="hljs-string">&#x27;content-length&#x27;</span>: stat.size,
    <span class="hljs-string">&#x27;last-modified&#x27;</span>: stat.mtime.toUTCString(),
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>
  };
  stream.respondWithFD(fd, headers, { <span class="hljs-attr">waitForTrailers</span>: <span class="hljs-literal">true</span> });
  stream.on(<span class="hljs-string">&#x27;wantTrailers&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    stream.sendTrailers({ <span class="hljs-attr">ABC</span>: <span class="hljs-string">&#x27;some value to send&#x27;</span> });
  });

  stream.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> fs.closeSync(fd));
});
</div></code></pre>
<h4 id="http2streamrespondwithfilepath-headers-options"><code>http2stream.respondWithFile(path[, headers[, options]])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version:
    - v14.5.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/33160
    description: Allow explicitly setting date headers.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18936
    description: Any readable file, not necessarily a
                 regular file, is supported now.
-->
<ul>
<li><code>path</code> {string|Buffer|URL}</li>
<li><code>headers</code> {HTTP/2 Headers Object}</li>
<li><code>options</code> {Object}
<ul>
<li><code>statCheck</code> {Function}</li>
<li><code>onError</code> {Function} Callback function invoked in the case of an
error before send.</li>
<li><code>waitForTrailers</code> {boolean} When <code>true</code>, the <code>Http2Stream</code> will emit the
<code>'wantTrailers'</code> event after the final <code>DATA</code> frame has been sent.</li>
<li><code>offset</code> {number} The offset position at which to begin reading.</li>
<li><code>length</code> {number} The amount of data from the fd to send.</li>
</ul>
</li>
</ul>
<p>Sends a regular file as the response. The <code>path</code> must specify a regular file
or an <code>'error'</code> event will be emitted on the <code>Http2Stream</code> object.</p>
<p>When used, the <code>Http2Stream</code> object's <code>Duplex</code> interface will be closed
automatically.</p>
<p>The optional <code>options.statCheck</code> function may be specified to give user code
an opportunity to set additional content headers based on the <code>fs.Stat</code> details
of the given file:</p>
<p>If an error occurs while attempting to read the file data, the <code>Http2Stream</code>
will be closed using an <code>RST_STREAM</code> frame using the standard <code>INTERNAL_ERROR</code>
code. If the <code>onError</code> callback is defined, then it will be called. Otherwise
the stream will be destroyed.</p>
<p>Example using a file path:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">statCheck</span>(<span class="hljs-params">stat, headers</span>) </span>{
    headers[<span class="hljs-string">&#x27;last-modified&#x27;</span>] = stat.mtime.toUTCString();
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onError</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-comment">// stream.respond() can throw if the stream has been destroyed by</span>
    <span class="hljs-comment">// the other side.</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (err.code === <span class="hljs-string">&#x27;ENOENT&#x27;</span>) {
        stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">404</span> });
      } <span class="hljs-keyword">else</span> {
        stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">500</span> });
      }
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-comment">// Perform actual error handling.</span>
      <span class="hljs-built_in">console</span>.log(err);
    }
    stream.end();
  }

  stream.respondWithFile(<span class="hljs-string">&#x27;/some/file&#x27;</span>,
                         { <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> },
                         { statCheck, onError });
});
</div></code></pre>
<p>The <code>options.statCheck</code> function may also be used to cancel the send operation
by returning <code>false</code>. For instance, a conditional request may check the stat
results to determine if the file has been modified to return an appropriate
<code>304</code> response:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">statCheck</span>(<span class="hljs-params">stat, headers</span>) </span>{
    <span class="hljs-comment">// Check the stat here...</span>
    stream.respond({ <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">304</span> });
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Cancel the send operation</span>
  }
  stream.respondWithFile(<span class="hljs-string">&#x27;/some/file&#x27;</span>,
                         { <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> },
                         { statCheck });
});
</div></code></pre>
<p>The <code>content-length</code> header field will be automatically set.</p>
<p>The <code>offset</code> and <code>length</code> options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.</p>
<p>The <code>options.onError</code> function may also be used to handle all the errors
that could happen before the delivery of the file is initiated. The
default behavior is to destroy the stream.</p>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>'wantTrailers'</code> event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The <code>http2stream.sendTrailers()</code> method can then be used to sent trailing
header fields to the peer.</p>
<p>When <code>options.waitForTrailers</code> is set, the <code>Http2Stream</code> will not automatically
close when the final <code>DATA</code> frame is transmitted. User code must call either
<code>http2stream.sendTrailers()</code> or <code>http2stream.close()</code> to close the
<code>Http2Stream</code>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  stream.respondWithFile(<span class="hljs-string">&#x27;/some/file&#x27;</span>,
                         { <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> },
                         { <span class="hljs-attr">waitForTrailers</span>: <span class="hljs-literal">true</span> });
  stream.on(<span class="hljs-string">&#x27;wantTrailers&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    stream.sendTrailers({ <span class="hljs-attr">ABC</span>: <span class="hljs-string">&#x27;some value to send&#x27;</span> });
  });
});
</div></code></pre>
<h3 id="class-http2server">Class: <code>Http2Server</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {net.Server}</li>
</ul>
<p>Instances of <code>Http2Server</code> are created using the <code>http2.createServer()</code>
function. The <code>Http2Server</code> class is not exported directly by the <code>http2</code>
module.</p>
<h4 id="event-checkcontinue">Event: <code>'checkContinue'</code></h4>
<!-- YAML
added: v8.5.0
-->
<ul>
<li><code>request</code> {http2.Http2ServerRequest}</li>
<li><code>response</code> {http2.Http2ServerResponse}</li>
</ul>
<p>If a <a href="#event-request"><code>'request'</code></a> listener is registered or <a href="#http2createserveroptions-onrequesthandler"><code>http2.createServer()</code></a> is
supplied a callback function, the <code>'checkContinue'</code> event is emitted each time
a request with an HTTP <code>Expect: 100-continue</code> is received. If this event is
not listened for, the server will automatically respond with a status
<code>100 Continue</code> as appropriate.</p>
<p>Handling this event involves calling <a href="#responsewritecontinue"><code>response.writeContinue()</code></a> if the
client should continue to send the request body, or generating an appropriate
HTTP response (e.g. 400 Bad Request) if the client should not continue to send
the request body.</p>
<p>When this event is emitted and handled, the <a href="#event-request"><code>'request'</code></a> event will
not be emitted.</p>
<h4 id="event-connection">Event: <code>'connection'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>socket</code> {stream.Duplex}</li>
</ul>
<p>This event is emitted when a new TCP stream is established. <code>socket</code> is
typically an object of type <a href="net.md#class-netsocket"><code>net.Socket</code></a>. Usually users will not want to
access this event.</p>
<p>This event can also be explicitly emitted by users to inject connections
into the HTTP server. In that case, any <a href="stream.md#class-streamduplex"><code>Duplex</code></a> stream can be passed.</p>
<h4 id="event-request">Event: <code>'request'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>request</code> {http2.Http2ServerRequest}</li>
<li><code>response</code> {http2.Http2ServerResponse}</li>
</ul>
<p>Emitted each time there is a request. There may be multiple requests
per session. See the <a href="#compatibility-api">Compatibility API</a>.</p>
<h4 id="event-session">Event: <code>'session'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'session'</code> event is emitted when a new <code>Http2Session</code> is created by the
<code>Http2Server</code>.</p>
<h4 id="event-sessionerror">Event: <code>'sessionError'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'sessionError'</code> event is emitted when an <code>'error'</code> event is emitted by
an <code>Http2Session</code> object associated with the <code>Http2Server</code>.</p>
<h4 id="event-stream-1">Event: <code>'stream'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>stream</code> {Http2Stream} A reference to the stream</li>
<li><code>headers</code> {HTTP/2 Headers Object} An object describing the headers</li>
<li><code>flags</code> {number} The associated numeric flags</li>
<li><code>rawHeaders</code> {Array} An array containing the raw header names followed by
their respective values.</li>
</ul>
<p>The <code>'stream'</code> event is emitted when a <code>'stream'</code> event has been emitted by
an <code>Http2Session</code> associated with the server.</p>
<p>See also <a href="#event-stream"><code>Http2Session</code>'s <code>'stream'</code> event</a>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> {
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE
} = http2.constants;

<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers, flags</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> method = headers[HTTP2_HEADER_METHOD];
  <span class="hljs-keyword">const</span> path = headers[HTTP2_HEADER_PATH];
  <span class="hljs-comment">// ...</span>
  stream.respond({
    [HTTP2_HEADER_STATUS]: <span class="hljs-number">200</span>,
    [HTTP2_HEADER_CONTENT_TYPE]: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>
  });
  stream.write(<span class="hljs-string">&#x27;hello &#x27;</span>);
  stream.end(<span class="hljs-string">&#x27;world&#x27;</span>);
});
</div></code></pre>
<h4 id="event-timeout-2">Event: <code>'timeout'</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/27558
    description: The default timeout changed from 120s to 0 (no timeout).
-->
<p>The <code>'timeout'</code> event is emitted when there is no activity on the Server for
a given number of milliseconds set using <code>http2server.setTimeout()</code>.
<strong>Default:</strong> 0 (no timeout)</p>
<h4 id="serverclosecallback"><code>server.close([callback])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>callback</code> {Function}</li>
</ul>
<p>Stops the server from establishing new sessions. This does not prevent new
request streams from being created due to the persistent nature of HTTP/2
sessions. To gracefully shut down the server, call <a href="#http2sessionclosecallback"><code>http2session.close()</code></a> on
all active sessions.</p>
<p>If <code>callback</code> is provided, it is not invoked until all active sessions have been
closed, although the server has already stopped allowing new sessions. See
<a href="net.md#serverclosecallback"><code>net.Server.close()</code></a> for more details.</p>
<h4 id="serversettimeoutmsecs"><code>server.setTimeout([msecs][, callback])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/27558
    description: The default timeout changed from 120s to 0 (no timeout).
-->
<ul>
<li><code>msecs</code> {number} <strong>Default:</strong> 0 (no timeout)</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {Http2Server}</li>
</ul>
<p>Used to set the timeout value for http2 server requests,
and sets a callback function that is called when there is no activity
on the <code>Http2Server</code> after <code>msecs</code> milliseconds.</p>
<p>The given callback is registered as a listener on the <code>'timeout'</code> event.</p>
<p>In case if <code>callback</code> is not a function, a new <code>ERR_INVALID_ARG_TYPE</code>
error will be thrown.</p>
<h4 id="servertimeout"><code>server.timeout</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/27558
    description: The default timeout changed from 120s to 0 (no timeout).
-->
<ul>
<li>{number} Timeout in milliseconds. <strong>Default:</strong> 0 (no timeout)</li>
</ul>
<p>The number of milliseconds of inactivity before a socket is presumed
to have timed out.</p>
<p>A value of <code>0</code> will disable the timeout behavior on incoming connections.</p>
<p>The socket timeout logic is set up on connection, so changing this
value only affects new connections to the server, not any existing connections.</p>
<h4 id="serverupdatesettingssettings"><code>server.updateSettings([settings])</code></h4>
<!-- YAML
added:
  - v15.1.0
  - v14.17.0
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object}</li>
</ul>
<p>Used to update the server with the provided settings.</p>
<p>Throws <code>ERR_HTTP2_INVALID_SETTING_VALUE</code> for invalid <code>settings</code> values.</p>
<p>Throws <code>ERR_INVALID_ARG_TYPE</code> for invalid <code>settings</code> argument.</p>
<h3 id="class-http2secureserver">Class: <code>Http2SecureServer</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {tls.Server}</li>
</ul>
<p>Instances of <code>Http2SecureServer</code> are created using the
<code>http2.createSecureServer()</code> function. The <code>Http2SecureServer</code> class is not
exported directly by the <code>http2</code> module.</p>
<h4 id="event-checkcontinue-1">Event: <code>'checkContinue'</code></h4>
<!-- YAML
added: v8.5.0
-->
<ul>
<li><code>request</code> {http2.Http2ServerRequest}</li>
<li><code>response</code> {http2.Http2ServerResponse}</li>
</ul>
<p>If a <a href="#event-request"><code>'request'</code></a> listener is registered or <a href="#http2createsecureserveroptions-onrequesthandler"><code>http2.createSecureServer()</code></a>
is supplied a callback function, the <code>'checkContinue'</code> event is emitted each
time a request with an HTTP <code>Expect: 100-continue</code> is received. If this event
is not listened for, the server will automatically respond with a status
<code>100 Continue</code> as appropriate.</p>
<p>Handling this event involves calling <a href="#responsewritecontinue"><code>response.writeContinue()</code></a> if the
client should continue to send the request body, or generating an appropriate
HTTP response (e.g. 400 Bad Request) if the client should not continue to send
the request body.</p>
<p>When this event is emitted and handled, the <a href="#event-request"><code>'request'</code></a> event will
not be emitted.</p>
<h4 id="event-connection-1">Event: <code>'connection'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>socket</code> {stream.Duplex}</li>
</ul>
<p>This event is emitted when a new TCP stream is established, before the TLS
handshake begins. <code>socket</code> is typically an object of type <a href="net.md#class-netsocket"><code>net.Socket</code></a>.
Usually users will not want to access this event.</p>
<p>This event can also be explicitly emitted by users to inject connections
into the HTTP server. In that case, any <a href="stream.md#class-streamduplex"><code>Duplex</code></a> stream can be passed.</p>
<h4 id="event-request-1">Event: <code>'request'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>request</code> {http2.Http2ServerRequest}</li>
<li><code>response</code> {http2.Http2ServerResponse}</li>
</ul>
<p>Emitted each time there is a request. There may be multiple requests
per session. See the <a href="#compatibility-api">Compatibility API</a>.</p>
<h4 id="event-session-1">Event: <code>'session'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'session'</code> event is emitted when a new <code>Http2Session</code> is created by the
<code>Http2SecureServer</code>.</p>
<h4 id="event-sessionerror-1">Event: <code>'sessionError'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'sessionError'</code> event is emitted when an <code>'error'</code> event is emitted by
an <code>Http2Session</code> object associated with the <code>Http2SecureServer</code>.</p>
<h4 id="event-stream-2">Event: <code>'stream'</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>stream</code> {Http2Stream} A reference to the stream</li>
<li><code>headers</code> {HTTP/2 Headers Object} An object describing the headers</li>
<li><code>flags</code> {number} The associated numeric flags</li>
<li><code>rawHeaders</code> {Array} An array containing the raw header names followed by
their respective values.</li>
</ul>
<p>The <code>'stream'</code> event is emitted when a <code>'stream'</code> event has been emitted by
an <code>Http2Session</code> associated with the server.</p>
<p>See also <a href="#event-stream"><code>Http2Session</code>'s <code>'stream'</code> event</a>.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> {
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE
} = http2.constants;

<span class="hljs-keyword">const</span> options = getOptionsSomehow();

<span class="hljs-keyword">const</span> server = http2.createSecureServer(options);
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers, flags</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> method = headers[HTTP2_HEADER_METHOD];
  <span class="hljs-keyword">const</span> path = headers[HTTP2_HEADER_PATH];
  <span class="hljs-comment">// ...</span>
  stream.respond({
    [HTTP2_HEADER_STATUS]: <span class="hljs-number">200</span>,
    [HTTP2_HEADER_CONTENT_TYPE]: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>
  });
  stream.write(<span class="hljs-string">&#x27;hello &#x27;</span>);
  stream.end(<span class="hljs-string">&#x27;world&#x27;</span>);
});
</div></code></pre>
<h4 id="event-timeout-3">Event: <code>'timeout'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'timeout'</code> event is emitted when there is no activity on the Server for
a given number of milliseconds set using <code>http2secureServer.setTimeout()</code>.
<strong>Default:</strong> 2 minutes.</p>
<h4 id="event-unknownprotocol">Event: <code>'unknownProtocol'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'unknownProtocol'</code> event is emitted when a connecting client fails to
negotiate an allowed protocol (i.e. HTTP/2 or HTTP/1.1). The event handler
receives the socket for handling. If no listener is registered for this event,
the connection is terminated. A timeout may be specified using the
<code>'unknownProtocolTimeout'</code> option passed to <a href="#http2createsecureserveroptions-onrequesthandler"><code>http2.createSecureServer()</code></a>.
See the <a href="#compatibility-api">Compatibility API</a>.</p>
<h4 id="serverclosecallback-1"><code>server.close([callback])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>callback</code> {Function}</li>
</ul>
<p>Stops the server from establishing new sessions. This does not prevent new
request streams from being created due to the persistent nature of HTTP/2
sessions. To gracefully shut down the server, call <a href="#http2sessionclosecallback"><code>http2session.close()</code></a> on
all active sessions.</p>
<p>If <code>callback</code> is provided, it is not invoked until all active sessions have been
closed, although the server has already stopped allowing new sessions. See
<a href="tls.md#serverclosecallback"><code>tls.Server.close()</code></a> for more details.</p>
<h4 id="serversettimeoutmsecs-1"><code>server.setTimeout([msecs][, callback])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>msecs</code> {number} <strong>Default:</strong> <code>120000</code> (2 minutes)</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {Http2SecureServer}</li>
</ul>
<p>Used to set the timeout value for http2 secure server requests,
and sets a callback function that is called when there is no activity
on the <code>Http2SecureServer</code> after <code>msecs</code> milliseconds.</p>
<p>The given callback is registered as a listener on the <code>'timeout'</code> event.</p>
<p>In case if <code>callback</code> is not a function, a new <code>ERR_INVALID_ARG_TYPE</code>
error will be thrown.</p>
<h4 id="servertimeout-1"><code>server.timeout</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/27558
    description: The default timeout changed from 120s to 0 (no timeout).
-->
<ul>
<li>{number} Timeout in milliseconds. <strong>Default:</strong> 0 (no timeout)</li>
</ul>
<p>The number of milliseconds of inactivity before a socket is presumed
to have timed out.</p>
<p>A value of <code>0</code> will disable the timeout behavior on incoming connections.</p>
<p>The socket timeout logic is set up on connection, so changing this
value only affects new connections to the server, not any existing connections.</p>
<h4 id="serverupdatesettingssettings-1"><code>server.updateSettings([settings])</code></h4>
<!-- YAML
added:
  - v15.1.0
  - v14.17.0
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object}</li>
</ul>
<p>Used to update the server with the provided settings.</p>
<p>Throws <code>ERR_HTTP2_INVALID_SETTING_VALUE</code> for invalid <code>settings</code> values.</p>
<p>Throws <code>ERR_INVALID_ARG_TYPE</code> for invalid <code>settings</code> argument.</p>
<h3 id="http2createserveroptions-onrequesthandler"><code>http2.createServer(options[, onRequestHandler])</code></h3>
<!-- YAML
added: v8.4.0
changes:
  - version:
      - v15.10.0
      - v14.16.0
      - v12.21.0
      - v10.24.0
    pr-url: https://github.com/nodejs-private/node-private/pull/246
    description: Added `unknownProtocolTimeout` option with a default of 10000.
  - version:
     - v14.4.0
     - v12.18.0
     - v10.21.0
    commit: 3948830ce6408be620b09a70bf66158623022af0
    pr-url: https://github.com/nodejs-private/node-private/pull/204
    description: Added `maxSettings` option with a default of 32.
  - version:
     - v13.3.0
     - v12.16.0
    pr-url: https://github.com/nodejs/node/pull/30534
    description: Added `maxSessionRejectedStreams` option with a default of 100.
  - version:
     - v13.3.0
     - v12.16.0
    pr-url: https://github.com/nodejs/node/pull/30534
    description: Added `maxSessionInvalidFrames` option with a default of 1000.
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/29144
    description: The `PADDING_STRATEGY_CALLBACK` has been made equivalent to
                 providing `PADDING_STRATEGY_ALIGNED` and `selectPadding`
                 has been removed.
  - version: v12.4.0
    pr-url: https://github.com/nodejs/node/pull/27782
    description: The `options` parameter now supports `net.createServer()`
                 options.
  - version: v9.6.0
    pr-url: https://github.com/nodejs/node/pull/15752
    description: Added the `Http1IncomingMessage` and `Http1ServerResponse`
                 option.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/17105
    description: Added the `maxOutstandingPings` option with a default limit of
                 10.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/16676
    description: Added the `maxHeaderListPairs` option with a default limit of
                 128 header pairs.
-->
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>maxDeflateDynamicTableSize</code> {number} Sets the maximum dynamic table size
for deflating header fields. <strong>Default:</strong> <code>4Kib</code>.</li>
<li><code>maxSettings</code> {number} Sets the maximum number of settings entries per
<code>SETTINGS</code> frame. The minimum value allowed is <code>1</code>. <strong>Default:</strong> <code>32</code>.</li>
<li><code>maxSessionMemory</code>{number} Sets the maximum memory that the <code>Http2Session</code>
is permitted to use. The value is expressed in terms of number of megabytes,
e.g. <code>1</code> equal 1 megabyte. The minimum value allowed is <code>1</code>.
This is a credit based limit, existing <code>Http2Stream</code>s may cause this
limit to be exceeded, but new <code>Http2Stream</code> instances will be rejected
while this limit is exceeded. The current number of <code>Http2Stream</code> sessions,
the current memory use of the header compression tables, current data
queued to be sent, and unacknowledged <code>PING</code> and <code>SETTINGS</code> frames are all
counted towards the current limit. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxHeaderListPairs</code> {number} Sets the maximum number of header entries.
This is similar to <a href="http.md#servermaxheaderscount"><code>http.Server#maxHeadersCount</code></a> or
<a href="http.md#requestmaxheaderscount"><code>http.ClientRequest#maxHeadersCount</code></a>. The minimum value is <code>4</code>.
<strong>Default:</strong> <code>128</code>.</li>
<li><code>maxOutstandingPings</code> {number} Sets the maximum number of outstanding,
unacknowledged pings. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxSendHeaderBlockLength</code> {number} Sets the maximum allowed size for a
serialized, compressed block of headers. Attempts to send headers that
exceed this limit will result in a <code>'frameError'</code> event being emitted
and the stream being closed and destroyed.</li>
<li><code>paddingStrategy</code> {number} The strategy used for determining the amount of
padding to use for <code>HEADERS</code> and <code>DATA</code> frames. <strong>Default:</strong>
<code>http2.constants.PADDING_STRATEGY_NONE</code>. Value may be one of:
<ul>
<li><code>http2.constants.PADDING_STRATEGY_NONE</code>: No padding is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_MAX</code>: The maximum amount of padding,
determined by the internal implementation, is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_ALIGNED</code>: Attempts to apply enough
padding to ensure that the total frame length, including the 9-byte
header, is a multiple of 8. For each frame, there is a maximum allowed
number of padding bytes that is determined by current flow control state
and settings. If this maximum is less than the calculated amount needed to
ensure alignment, the maximum is used and the total frame length is not
necessarily aligned at 8 bytes.</li>
</ul>
</li>
<li><code>peerMaxConcurrentStreams</code> {number} Sets the maximum number of concurrent
streams for the remote peer as if a <code>SETTINGS</code> frame had been received. Will
be overridden if the remote peer sets its own value for
<code>maxConcurrentStreams</code>. <strong>Default:</strong> <code>100</code>.</li>
<li><code>maxSessionInvalidFrames</code> {integer} Sets the maximum number of invalid
frames that will be tolerated before the session is closed.
<strong>Default:</strong> <code>1000</code>.</li>
<li><code>maxSessionRejectedStreams</code> {integer} Sets the maximum number of rejected
upon creation streams that will be tolerated before the session is closed.
Each rejection is associated with an <code>NGHTTP2_ENHANCE_YOUR_CALM</code>
error that should tell the peer to not open any more streams, continuing
to open streams is therefore regarded as a sign of a misbehaving peer.
<strong>Default:</strong> <code>100</code>.</li>
<li><code>settings</code> {HTTP/2 Settings Object} The initial settings to send to the
remote peer upon connection.</li>
<li><code>Http1IncomingMessage</code> {http.IncomingMessage} Specifies the
<code>IncomingMessage</code> class to used for HTTP/1 fallback. Useful for extending
the original <code>http.IncomingMessage</code>. <strong>Default:</strong> <code>http.IncomingMessage</code>.</li>
<li><code>Http1ServerResponse</code> {http.ServerResponse} Specifies the <code>ServerResponse</code>
class to used for HTTP/1 fallback. Useful for extending the original
<code>http.ServerResponse</code>. <strong>Default:</strong> <code>http.ServerResponse</code>.</li>
<li><code>Http2ServerRequest</code> {http2.Http2ServerRequest} Specifies the
<code>Http2ServerRequest</code> class to use.
Useful for extending the original <code>Http2ServerRequest</code>.
<strong>Default:</strong> <code>Http2ServerRequest</code>.</li>
<li><code>Http2ServerResponse</code> {http2.Http2ServerResponse} Specifies the
<code>Http2ServerResponse</code> class to use.
Useful for extending the original <code>Http2ServerResponse</code>.
<strong>Default:</strong> <code>Http2ServerResponse</code>.</li>
<li><code>unknownProtocolTimeout</code> {number} Specifies a timeout in milliseconds that
a server should wait when an <a href="#event-unknownprotocol"><code>'unknownProtocol'</code></a> is emitted. If the
socket has not been destroyed by that time the server will destroy it.
<strong>Default:</strong> <code>10000</code>.</li>
<li>...: Any <a href="net.md#netcreateserveroptions-connectionlistener"><code>net.createServer()</code></a> option can be provided.</li>
</ul>
</li>
<li><code>onRequestHandler</code> {Function} See <a href="#compatibility-api">Compatibility API</a></li>
<li>Returns: {Http2Server}</li>
</ul>
<p>Returns a <code>net.Server</code> instance that creates and manages <code>Http2Session</code>
instances.</p>
<p>Since there are no browsers known that support
<a href="https://http2.github.io/faq/#does-http2-require-encryption">unencrypted HTTP/2</a>, the use of
<a href="#http2createsecureserveroptions-onrequesthandler"><code>http2.createSecureServer()</code></a> is necessary when communicating
with browser clients.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-comment">// Create an unencrypted HTTP/2 server.</span>
<span class="hljs-comment">// Since there are no browsers known that support</span>
<span class="hljs-comment">// unencrypted HTTP/2, the use of `http2.createSecureServer()`</span>
<span class="hljs-comment">// is necessary when communicating with browser clients.</span>
<span class="hljs-keyword">const</span> server = http2.createServer();

server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  stream.respond({
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>,
    <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>
  });
  stream.end(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);
});

server.listen(<span class="hljs-number">80</span>);
</div></code></pre>
<h3 id="http2createsecureserveroptions-onrequesthandler"><code>http2.createSecureServer(options[, onRequestHandler])</code></h3>
<!-- YAML
added: v8.4.0
changes:
  - version:
      - v15.10.0
      - v14.16.0
      - v12.21.0
      - v10.24.0
    pr-url: https://github.com/nodejs-private/node-private/pull/246
    description: Added `unknownProtocolTimeout` option with a default of 10000.
  - version:
     - v14.4.0
     - v12.18.0
     - v10.21.0
    commit: 3948830ce6408be620b09a70bf66158623022af0
    pr-url: https://github.com/nodejs-private/node-private/pull/204
    description: Added `maxSettings` option with a default of 32.
  - version:
     - v13.3.0
     - v12.16.0
    pr-url: https://github.com/nodejs/node/pull/30534
    description: Added `maxSessionRejectedStreams` option with a default of 100.
  - version:
     - v13.3.0
     - v12.16.0
    pr-url: https://github.com/nodejs/node/pull/30534
    description: Added `maxSessionInvalidFrames` option with a default of 1000.
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/29144
    description: The `PADDING_STRATEGY_CALLBACK` has been made equivalent to
                 providing `PADDING_STRATEGY_ALIGNED` and `selectPadding`
                 has been removed.
  - version: v10.12.0
    pr-url: https://github.com/nodejs/node/pull/22956
    description: Added the `origins` option to automatically send an `ORIGIN`
                 frame on `Http2Session` startup.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/17105
    description: Added the `maxOutstandingPings` option with a default limit of
                 10.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/16676
    description: Added the `maxHeaderListPairs` option with a default limit of
                 128 header pairs.
-->
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>allowHTTP1</code> {boolean} Incoming client connections that do not support
HTTP/2 will be downgraded to HTTP/1.x when set to <code>true</code>.
See the <a href="#event-unknownprotocol"><code>'unknownProtocol'</code></a> event. See <a href="#alpn-negotiation">ALPN negotiation</a>.
<strong>Default:</strong> <code>false</code>.</li>
<li><code>maxDeflateDynamicTableSize</code> {number} Sets the maximum dynamic table size
for deflating header fields. <strong>Default:</strong> <code>4Kib</code>.</li>
<li><code>maxSettings</code> {number} Sets the maximum number of settings entries per
<code>SETTINGS</code> frame. The minimum value allowed is <code>1</code>. <strong>Default:</strong> <code>32</code>.</li>
<li><code>maxSessionMemory</code>{number} Sets the maximum memory that the <code>Http2Session</code>
is permitted to use. The value is expressed in terms of number of megabytes,
e.g. <code>1</code> equal 1 megabyte. The minimum value allowed is <code>1</code>. This is a
credit based limit, existing <code>Http2Stream</code>s may cause this
limit to be exceeded, but new <code>Http2Stream</code> instances will be rejected
while this limit is exceeded. The current number of <code>Http2Stream</code> sessions,
the current memory use of the header compression tables, current data
queued to be sent, and unacknowledged <code>PING</code> and <code>SETTINGS</code> frames are all
counted towards the current limit. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxHeaderListPairs</code> {number} Sets the maximum number of header entries.
This is similar to <a href="http.md#servermaxheaderscount"><code>http.Server#maxHeadersCount</code></a> or
<a href="http.md#requestmaxheaderscount"><code>http.ClientRequest#maxHeadersCount</code></a>. The minimum value is <code>4</code>.
<strong>Default:</strong> <code>128</code>.</li>
<li><code>maxOutstandingPings</code> {number} Sets the maximum number of outstanding,
unacknowledged pings. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxSendHeaderBlockLength</code> {number} Sets the maximum allowed size for a
serialized, compressed block of headers. Attempts to send headers that
exceed this limit will result in a <code>'frameError'</code> event being emitted
and the stream being closed and destroyed.</li>
<li><code>paddingStrategy</code> {number} Strategy used for determining the amount of
padding to use for <code>HEADERS</code> and <code>DATA</code> frames. <strong>Default:</strong>
<code>http2.constants.PADDING_STRATEGY_NONE</code>. Value may be one of:
<ul>
<li><code>http2.constants.PADDING_STRATEGY_NONE</code>: No padding is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_MAX</code>: The maximum amount of padding,
determined by the internal implementation, is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_ALIGNED</code>: Attempts to apply enough
padding to ensure that the total frame length, including the
9-byte header, is a multiple of 8. For each frame, there is a maximum
allowed number of padding bytes that is determined by current flow control
state and settings. If this maximum is less than the calculated amount
needed to ensure alignment, the maximum is used and the total frame length
is not necessarily aligned at 8 bytes.</li>
</ul>
</li>
<li><code>peerMaxConcurrentStreams</code> {number} Sets the maximum number of concurrent
streams for the remote peer as if a <code>SETTINGS</code> frame had been received. Will
be overridden if the remote peer sets its own value for
<code>maxConcurrentStreams</code>. <strong>Default:</strong> <code>100</code>.</li>
<li><code>maxSessionInvalidFrames</code> {integer} Sets the maximum number of invalid
frames that will be tolerated before the session is closed.
<strong>Default:</strong> <code>1000</code>.</li>
<li><code>maxSessionRejectedStreams</code> {integer} Sets the maximum number of rejected
upon creation streams that will be tolerated before the session is closed.
Each rejection is associated with an <code>NGHTTP2_ENHANCE_YOUR_CALM</code>
error that should tell the peer to not open any more streams, continuing
to open streams is therefore regarded as a sign of a misbehaving peer.
<strong>Default:</strong> <code>100</code>.</li>
<li><code>settings</code> {HTTP/2 Settings Object} The initial settings to send to the
remote peer upon connection.</li>
<li>...: Any <a href="tls.md#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> options can be provided. For
servers, the identity options (<code>pfx</code> or <code>key</code>/<code>cert</code>) are usually required.</li>
<li><code>origins</code> {string[]} An array of origin strings to send within an <code>ORIGIN</code>
frame immediately following creation of a new server <code>Http2Session</code>.</li>
<li><code>unknownProtocolTimeout</code> {number} Specifies a timeout in milliseconds that
a server should wait when an <a href="#event-unknownprotocol"><code>'unknownProtocol'</code></a> event is emitted. If
the socket has not been destroyed by that time the server will destroy it.
<strong>Default:</strong> <code>10000</code>.</li>
</ul>
</li>
<li><code>onRequestHandler</code> {Function} See <a href="#compatibility-api">Compatibility API</a></li>
<li>Returns: {Http2SecureServer}</li>
</ul>
<p>Returns a <code>tls.Server</code> instance that creates and manages <code>Http2Session</code>
instances.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">key</span>: fs.readFileSync(<span class="hljs-string">&#x27;server-key.pem&#x27;</span>),
  <span class="hljs-attr">cert</span>: fs.readFileSync(<span class="hljs-string">&#x27;server-cert.pem&#x27;</span>)
};

<span class="hljs-comment">// Create a secure HTTP/2 server</span>
<span class="hljs-keyword">const</span> server = http2.createSecureServer(options);

server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  stream.respond({
    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>,
    <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span>
  });
  stream.end(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);
});

server.listen(<span class="hljs-number">80</span>);
</div></code></pre>
<h3 id="http2connectauthority-options"><code>http2.connect(authority[, options][, listener])</code></h3>
<!-- YAML
added: v8.4.0
changes:
  - version:
      - v15.10.0
      - v14.16.0
      - v12.21.0
      - v10.24.0
    pr-url: https://github.com/nodejs-private/node-private/pull/246
    description: Added `unknownProtocolTimeout` option with a default of 10000.
  - version:
     - v14.4.0
     - v12.18.0
     - v10.21.0
    commit: 3948830ce6408be620b09a70bf66158623022af0
    pr-url: https://github.com/nodejs-private/node-private/pull/204
    description: Added `maxSettings` option with a default of 32.
  - version: v13.0.0
    pr-url: https://github.com/nodejs/node/pull/29144
    description: The `PADDING_STRATEGY_CALLBACK` has been made equivalent to
                 providing `PADDING_STRATEGY_ALIGNED` and `selectPadding`
                 has been removed.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/17105
    description: Added the `maxOutstandingPings` option with a default limit of
                 10.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/16676
    description: Added the `maxHeaderListPairs` option with a default limit of
                 128 header pairs.
-->
<ul>
<li><code>authority</code> {string|URL} The remote HTTP/2 server to connect to. This must
be in the form of a minimal, valid URL with the <code>http://</code> or <code>https://</code>
prefix, host name, and IP port (if a non-default port is used). Userinfo
(user ID and password), path, querystring, and fragment details in the
URL will be ignored.</li>
<li><code>options</code> {Object}
<ul>
<li><code>maxDeflateDynamicTableSize</code> {number} Sets the maximum dynamic table size
for deflating header fields. <strong>Default:</strong> <code>4Kib</code>.</li>
<li><code>maxSettings</code> {number} Sets the maximum number of settings entries per
<code>SETTINGS</code> frame. The minimum value allowed is <code>1</code>. <strong>Default:</strong> <code>32</code>.</li>
<li><code>maxSessionMemory</code>{number} Sets the maximum memory that the <code>Http2Session</code>
is permitted to use. The value is expressed in terms of number of megabytes,
e.g. <code>1</code> equal 1 megabyte. The minimum value allowed is <code>1</code>.
This is a credit based limit, existing <code>Http2Stream</code>s may cause this
limit to be exceeded, but new <code>Http2Stream</code> instances will be rejected
while this limit is exceeded. The current number of <code>Http2Stream</code> sessions,
the current memory use of the header compression tables, current data
queued to be sent, and unacknowledged <code>PING</code> and <code>SETTINGS</code> frames are all
counted towards the current limit. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxHeaderListPairs</code> {number} Sets the maximum number of header entries.
This is similar to <a href="http.md#servermaxheaderscount"><code>http.Server#maxHeadersCount</code></a> or
<a href="http.md#requestmaxheaderscount"><code>http.ClientRequest#maxHeadersCount</code></a>. The minimum value is <code>1</code>.
<strong>Default:</strong> <code>128</code>.</li>
<li><code>maxOutstandingPings</code> {number} Sets the maximum number of outstanding,
unacknowledged pings. <strong>Default:</strong> <code>10</code>.</li>
<li><code>maxReservedRemoteStreams</code> {number} Sets the maximum number of reserved push
streams the client will accept at any given time. Once the current number of
currently reserved push streams exceeds reaches this limit, new push streams
sent by the server will be automatically rejected. The minimum allowed value
is 0. The maximum allowed value is 2<sup>32</sup>-1. A negative value sets
this option to the maximum allowed value. <strong>Default:</strong> <code>200</code>.</li>
<li><code>maxSendHeaderBlockLength</code> {number} Sets the maximum allowed size for a
serialized, compressed block of headers. Attempts to send headers that
exceed this limit will result in a <code>'frameError'</code> event being emitted
and the stream being closed and destroyed.</li>
<li><code>paddingStrategy</code> {number} Strategy used for determining the amount of
padding to use for <code>HEADERS</code> and <code>DATA</code> frames. <strong>Default:</strong>
<code>http2.constants.PADDING_STRATEGY_NONE</code>. Value may be one of:
<ul>
<li><code>http2.constants.PADDING_STRATEGY_NONE</code>: No padding is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_MAX</code>: The maximum amount of padding,
determined by the internal implementation, is applied.</li>
<li><code>http2.constants.PADDING_STRATEGY_ALIGNED</code>: Attempts to apply enough
padding to ensure that the total frame length, including the
9-byte header, is a multiple of 8. For each frame, there is a maximum
allowed number of padding bytes that is determined by current flow control
state and settings. If this maximum is less than the calculated amount
needed to ensure alignment, the maximum is used and the total frame length
is not necessarily aligned at 8 bytes.</li>
</ul>
</li>
<li><code>peerMaxConcurrentStreams</code> {number} Sets the maximum number of concurrent
streams for the remote peer as if a <code>SETTINGS</code> frame had been received. Will
be overridden if the remote peer sets its own value for
<code>maxConcurrentStreams</code>. <strong>Default:</strong> <code>100</code>.</li>
<li><code>protocol</code> {string} The protocol to connect with, if not set in the
<code>authority</code>. Value may be either <code>'http:'</code> or <code>'https:'</code>. <strong>Default:</strong>
<code>'https:'</code></li>
<li><code>settings</code> {HTTP/2 Settings Object} The initial settings to send to the
remote peer upon connection.</li>
<li><code>createConnection</code> {Function} An optional callback that receives the <code>URL</code>
instance passed to <code>connect</code> and the <code>options</code> object, and returns any
<a href="stream.md#class-streamduplex"><code>Duplex</code></a> stream that is to be used as the connection for this session.</li>
<li>...: Any <a href="net.md#netconnect"><code>net.connect()</code></a> or <a href="tls.md#tlsconnectoptions-callback"><code>tls.connect()</code></a> options can be provided.</li>
<li><code>unknownProtocolTimeout</code> {number} Specifies a timeout in milliseconds that
a server should wait when an <a href="#event-unknownprotocol"><code>'unknownProtocol'</code></a> event is emitted. If
the socket has not been destroyed by that time the server will destroy it.
<strong>Default:</strong> <code>10000</code>.</li>
</ul>
</li>
<li><code>listener</code> {Function} Will be registered as a one-time listener of the
<a href="#event-connect"><code>'connect'</code></a> event.</li>
<li>Returns: {ClientHttp2Session}</li>
</ul>
<p>Returns a <code>ClientHttp2Session</code> instance.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;https://localhost:1234&#x27;</span>);

<span class="hljs-comment">/* Use the client */</span>

client.close();
</div></code></pre>
<h3 id="http2constants"><code>http2.constants</code></h3>
<!-- YAML
added: v8.4.0
-->
<h4 id="error-codes-for-rst_stream-and-goaway">Error codes for <code>RST_STREAM</code> and <code>GOAWAY</code></h4>
<table>
<thead>
<tr>
<th>Value</th>
<th>Name</th>
<th>Constant</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x00</code></td>
<td>No Error</td>
<td><code>http2.constants.NGHTTP2_NO_ERROR</code></td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>Protocol Error</td>
<td><code>http2.constants.NGHTTP2_PROTOCOL_ERROR</code></td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>Internal Error</td>
<td><code>http2.constants.NGHTTP2_INTERNAL_ERROR</code></td>
</tr>
<tr>
<td><code>0x03</code></td>
<td>Flow Control Error</td>
<td><code>http2.constants.NGHTTP2_FLOW_CONTROL_ERROR</code></td>
</tr>
<tr>
<td><code>0x04</code></td>
<td>Settings Timeout</td>
<td><code>http2.constants.NGHTTP2_SETTINGS_TIMEOUT</code></td>
</tr>
<tr>
<td><code>0x05</code></td>
<td>Stream Closed</td>
<td><code>http2.constants.NGHTTP2_STREAM_CLOSED</code></td>
</tr>
<tr>
<td><code>0x06</code></td>
<td>Frame Size Error</td>
<td><code>http2.constants.NGHTTP2_FRAME_SIZE_ERROR</code></td>
</tr>
<tr>
<td><code>0x07</code></td>
<td>Refused Stream</td>
<td><code>http2.constants.NGHTTP2_REFUSED_STREAM</code></td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>Cancel</td>
<td><code>http2.constants.NGHTTP2_CANCEL</code></td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>Compression Error</td>
<td><code>http2.constants.NGHTTP2_COMPRESSION_ERROR</code></td>
</tr>
<tr>
<td><code>0x0a</code></td>
<td>Connect Error</td>
<td><code>http2.constants.NGHTTP2_CONNECT_ERROR</code></td>
</tr>
<tr>
<td><code>0x0b</code></td>
<td>Enhance Your Calm</td>
<td><code>http2.constants.NGHTTP2_ENHANCE_YOUR_CALM</code></td>
</tr>
<tr>
<td><code>0x0c</code></td>
<td>Inadequate Security</td>
<td><code>http2.constants.NGHTTP2_INADEQUATE_SECURITY</code></td>
</tr>
<tr>
<td><code>0x0d</code></td>
<td>HTTP/1.1 Required</td>
<td><code>http2.constants.NGHTTP2_HTTP_1_1_REQUIRED</code></td>
</tr>
</tbody>
</table>
<p>The <code>'timeout'</code> event is emitted when there is no activity on the Server for
a given number of milliseconds set using <code>http2server.setTimeout()</code>.</p>
<h3 id="http2getdefaultsettings"><code>http2.getDefaultSettings()</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Returns: {HTTP/2 Settings Object}</li>
</ul>
<p>Returns an object containing the default settings for an <code>Http2Session</code>
instance. This method returns a new object instance every time it is called
so instances returned may be safely modified for use.</p>
<h3 id="http2getpackedsettingssettings"><code>http2.getPackedSettings([settings])</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>settings</code> {HTTP/2 Settings Object}</li>
<li>Returns: {Buffer}</li>
</ul>
<p>Returns a <code>Buffer</code> instance containing serialized representation of the given
HTTP/2 settings as specified in the <a href="https://tools.ietf.org/html/rfc7540">HTTP/2</a> specification. This is intended
for use with the <code>HTTP2-Settings</code> header field.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-keyword">const</span> packed = http2.getPackedSettings({ <span class="hljs-attr">enablePush</span>: <span class="hljs-literal">false</span> });

<span class="hljs-built_in">console</span>.log(packed.toString(<span class="hljs-string">&#x27;base64&#x27;</span>));
<span class="hljs-comment">// Prints: AAIAAAAA</span>
</div></code></pre>
<h3 id="http2getunpackedsettingsbuf"><code>http2.getUnpackedSettings(buf)</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>buf</code> {Buffer|TypedArray} The packed settings.</li>
<li>Returns: {HTTP/2 Settings Object}</li>
</ul>
<p>Returns a <a href="#settings-object">HTTP/2 Settings Object</a> containing the deserialized settings from
the given <code>Buffer</code> as generated by <code>http2.getPackedSettings()</code>.</p>
<h3 id="http2sensitiveheaders"><code>http2.sensitiveHeaders</code></h3>
<!-- YAML
added:
  - v15.0.0
  - v14.18.0
-->
<ul>
<li>{symbol}</li>
</ul>
<p>This symbol can be set as a property on the HTTP/2 headers object with an array
value in order to provide a list of headers considered sensitive.
See <a href="#sensitive-headers">Sensitive headers</a> for more details.</p>
<h3 id="headers-object">Headers object</h3>
<p>Headers are represented as own-properties on JavaScript objects. The property
keys will be serialized to lower-case. Property values should be strings (if
they are not they will be coerced to strings) or an <code>Array</code> of strings (in order
to send more than one value per header field).</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-string">&#x27;200&#x27;</span>,
  <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text-plain&#x27;</span>,
  <span class="hljs-string">&#x27;ABC&#x27;</span>: [<span class="hljs-string">&#x27;has&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;than&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>]
};

stream.respond(headers);
</div></code></pre>
<p>Header objects passed to callback functions will have a <code>null</code> prototype. This
means that normal JavaScript object methods such as
<code>Object.prototype.toString()</code> and <code>Object.prototype.hasOwnProperty()</code> will
not work.</p>
<p>For incoming headers:</p>
<ul>
<li>The <code>:status</code> header is converted to <code>number</code>.</li>
<li>Duplicates of <code>:status</code>, <code>:method</code>, <code>:authority</code>, <code>:scheme</code>, <code>:path</code>,
<code>:protocol</code>, <code>age</code>, <code>authorization</code>, <code>access-control-allow-credentials</code>,
<code>access-control-max-age</code>, <code>access-control-request-method</code>, <code>content-encoding</code>,
<code>content-language</code>, <code>content-length</code>, <code>content-location</code>, <code>content-md5</code>,
<code>content-range</code>, <code>content-type</code>, <code>date</code>, <code>dnt</code>, <code>etag</code>, <code>expires</code>, <code>from</code>,
<code>host</code>, <code>if-match</code>, <code>if-modified-since</code>, <code>if-none-match</code>, <code>if-range</code>,
<code>if-unmodified-since</code>, <code>last-modified</code>, <code>location</code>, <code>max-forwards</code>,
<code>proxy-authorization</code>, <code>range</code>, <code>referer</code>,<code>retry-after</code>, <code>tk</code>,
<code>upgrade-insecure-requests</code>, <code>user-agent</code> or <code>x-content-type-options</code> are
discarded.</li>
<li><code>set-cookie</code> is always an array. Duplicates are added to the array.</li>
<li>For duplicate <code>cookie</code> headers, the values are joined together with '; '.</li>
<li>For all other headers, the values are joined together with ', '.</li>
</ul>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer();
server.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers[<span class="hljs-string">&#x27;:path&#x27;</span>]);
  <span class="hljs-built_in">console</span>.log(headers.ABC);
});
</div></code></pre>
<h4 id="sensitive-headers">Sensitive headers</h4>
<p>HTTP2 headers can be marked as sensitive, which means that the HTTP/2
header compression algorithm will never index them. This can make sense for
header values with low entropy and that may be considered valuable to an
attacker, for example <code>Cookie</code> or <code>Authorization</code>. To achieve this, add
the header name to the <code>[http2.sensitiveHeaders]</code> property as an array:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-string">&#x27;200&#x27;</span>,
  <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text-plain&#x27;</span>,
  <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;some-cookie&#x27;</span>,
  <span class="hljs-string">&#x27;other-sensitive-header&#x27;</span>: <span class="hljs-string">&#x27;very secret data&#x27;</span>,
  [http2.sensitiveHeaders]: [<span class="hljs-string">&#x27;cookie&#x27;</span>, <span class="hljs-string">&#x27;other-sensitive-header&#x27;</span>]
};

stream.respond(headers);
</div></code></pre>
<p>For some headers, such as <code>Authorization</code> and short <code>Cookie</code> headers,
this flag is set automatically.</p>
<p>This property is also set for received headers. It will contain the names of
all headers marked as sensitive, including ones marked that way automatically.</p>
<h3 id="settings-object">Settings object</h3>
<!-- YAML
added: v8.4.0
changes:
  - version: v12.12.0
    pr-url: https://github.com/nodejs/node/pull/29833
    description: The `maxConcurrentStreams` setting is stricter.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/16676
    description: The `maxHeaderListSize` setting is now strictly enforced.
-->
<p>The <code>http2.getDefaultSettings()</code>, <code>http2.getPackedSettings()</code>,
<code>http2.createServer()</code>, <code>http2.createSecureServer()</code>,
<code>http2session.settings()</code>, <code>http2session.localSettings</code>, and
<code>http2session.remoteSettings</code> APIs either return or receive as input an
object that defines configuration settings for an <code>Http2Session</code> object.
These objects are ordinary JavaScript objects containing the following
properties.</p>
<ul>
<li><code>headerTableSize</code> {number} Specifies the maximum number of bytes used for
header compression. The minimum allowed value is 0. The maximum allowed value
is 2<sup>32</sup>-1. <strong>Default:</strong> <code>4096</code>.</li>
<li><code>enablePush</code> {boolean} Specifies <code>true</code> if HTTP/2 Push Streams are to be
permitted on the <code>Http2Session</code> instances. <strong>Default:</strong> <code>true</code>.</li>
<li><code>initialWindowSize</code> {number} Specifies the <em>sender's</em> initial window size in
bytes for stream-level flow control. The minimum allowed value is 0. The
maximum allowed value is 2<sup>32</sup>-1. <strong>Default:</strong> <code>65535</code>.</li>
<li><code>maxFrameSize</code> {number} Specifies the size in bytes of the largest frame
payload. The minimum allowed value is 16,384. The maximum allowed value is
2<sup>24</sup>-1. <strong>Default:</strong> <code>16384</code>.</li>
<li><code>maxConcurrentStreams</code> {number} Specifies the maximum number of concurrent
streams permitted on an <code>Http2Session</code>. There is no default value which
implies, at least theoretically, 2<sup>32</sup>-1 streams may be open
concurrently at any given time in an <code>Http2Session</code>. The minimum value
is 0. The maximum allowed value is 2<sup>32</sup>-1. <strong>Default:</strong>
<code>4294967295</code>.</li>
<li><code>maxHeaderListSize</code> {number} Specifies the maximum size (uncompressed octets)
of header list that will be accepted. The minimum allowed value is 0. The
maximum allowed value is 2<sup>32</sup>-1. <strong>Default:</strong> <code>65535</code>.</li>
<li><code>maxHeaderSize</code> {number} Alias for <code>maxHeaderListSize</code>.</li>
<li><code>enableConnectProtocol</code>{boolean} Specifies <code>true</code> if the &quot;Extended Connect
Protocol&quot; defined by <a href="https://tools.ietf.org/html/rfc8441">RFC 8441</a> is to be enabled. This setting is only
meaningful if sent by the server. Once the <code>enableConnectProtocol</code> setting
has been enabled for a given <code>Http2Session</code>, it cannot be disabled.
<strong>Default:</strong> <code>false</code>.</li>
</ul>
<p>All additional properties on the settings object are ignored.</p>
<h3 id="error-handling">Error handling</h3>
<p>There are several types of error conditions that may arise when using the
<code>http2</code> module:</p>
<p>Validation errors occur when an incorrect argument, option, or setting value is
passed in. These will always be reported by a synchronous <code>throw</code>.</p>
<p>State errors occur when an action is attempted at an incorrect time (for
instance, attempting to send data on a stream after it has closed). These will
be reported using either a synchronous <code>throw</code> or via an <code>'error'</code> event on
the <code>Http2Stream</code>, <code>Http2Session</code> or HTTP/2 Server objects, depending on where
and when the error occurs.</p>
<p>Internal errors occur when an HTTP/2 session fails unexpectedly. These will be
reported via an <code>'error'</code> event on the <code>Http2Session</code> or HTTP/2 Server objects.</p>
<p>Protocol errors occur when various HTTP/2 protocol constraints are violated.
These will be reported using either a synchronous <code>throw</code> or via an <code>'error'</code>
event on the <code>Http2Stream</code>, <code>Http2Session</code> or HTTP/2 Server objects, depending
on where and when the error occurs.</p>
<h3 id="invalid-character-handling-in-header-names-and-values">Invalid character handling in header names and values</h3>
<p>The HTTP/2 implementation applies stricter handling of invalid characters in
HTTP header names and values than the HTTP/1 implementation.</p>
<p>Header field names are <em>case-insensitive</em> and are transmitted over the wire
strictly as lower-case strings. The API provided by Node.js allows header
names to be set as mixed-case strings (e.g. <code>Content-Type</code>) but will convert
those to lower-case (e.g. <code>content-type</code>) upon transmission.</p>
<p>Header field-names <em>must only</em> contain one or more of the following ASCII
characters: <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>0</code>-<code>9</code>, <code>!</code>, <code>#</code>, <code>$</code>, <code>%</code>, <code>&amp;</code>, <code>'</code>, <code>*</code>, <code>+</code>,
<code>-</code>, <code>.</code>, <code>^</code>, <code>_</code>, <code>`</code> (backtick), <code>|</code>, and <code>~</code>.</p>
<p>Using invalid characters within an HTTP header field name will cause the
stream to be closed with a protocol error being reported.</p>
<p>Header field values are handled with more leniency but <em>should</em> not contain
new-line or carriage return characters and <em>should</em> be limited to US-ASCII
characters, per the requirements of the HTTP specification.</p>
<h3 id="push-streams-on-the-client">Push streams on the client</h3>
<p>To receive pushed streams on the client, set a listener for the <code>'stream'</code>
event on the <code>ClientHttp2Session</code>:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;http://localhost&#x27;</span>);

client.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">pushedStream, requestHeaders</span>) =&gt;</span> {
  pushedStream.on(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">responseHeaders</span>) =&gt;</span> {
    <span class="hljs-comment">// Process response headers</span>
  });
  pushedStream.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { <span class="hljs-comment">/* handle pushed data */</span> });
});

<span class="hljs-keyword">const</span> req = client.request({ <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span> });
</div></code></pre>
<h3 id="supporting-the-connect-method">Supporting the <code>CONNECT</code> method</h3>
<p>The <code>CONNECT</code> method is used to allow an HTTP/2 server to be used as a proxy
for TCP/IP connections.</p>
<p>A simple TCP Server:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);

<span class="hljs-keyword">const</span> server = net.createServer(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;&#x27;</span>;
  socket.setEncoding(<span class="hljs-string">&#x27;utf8&#x27;</span>);
  socket.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> name += chunk);
  socket.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> socket.end(<span class="hljs-string">`hello <span class="hljs-subst">${name}</span>`</span>));
});

server.listen(<span class="hljs-number">8000</span>);
</div></code></pre>
<p>An HTTP/2 CONNECT proxy:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> { NGHTTP2_REFUSED_STREAM } = http2.constants;
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);

<span class="hljs-keyword">const</span> proxy = http2.createServer();
proxy.on(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (headers[<span class="hljs-string">&#x27;:method&#x27;</span>] !== <span class="hljs-string">&#x27;CONNECT&#x27;</span>) {
    <span class="hljs-comment">// Only accept CONNECT requests</span>
    stream.close(NGHTTP2_REFUSED_STREAM);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> auth = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">`tcp://<span class="hljs-subst">${headers[<span class="hljs-string">&#x27;:authority&#x27;</span>]}</span>`</span>);
  <span class="hljs-comment">// It&#x27;s a very good idea to verify that hostname and port are</span>
  <span class="hljs-comment">// things this proxy should be connecting to.</span>
  <span class="hljs-keyword">const</span> socket = net.connect(auth.port, auth.hostname, <span class="hljs-function">() =&gt;</span> {
    stream.respond();
    socket.pipe(stream);
    stream.pipe(socket);
  });
  socket.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    stream.close(http2.constants.NGHTTP2_CONNECT_ERROR);
  });
});

proxy.listen(<span class="hljs-number">8001</span>);
</div></code></pre>
<p>An HTTP/2 CONNECT client:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);

<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;http://localhost:8001&#x27;</span>);

<span class="hljs-comment">// Must not specify the &#x27;:path&#x27; and &#x27;:scheme&#x27; headers</span>
<span class="hljs-comment">// for CONNECT requests or an error will be thrown.</span>
<span class="hljs-keyword">const</span> req = client.request({
  <span class="hljs-string">&#x27;:method&#x27;</span>: <span class="hljs-string">&#x27;CONNECT&#x27;</span>,
  <span class="hljs-string">&#x27;:authority&#x27;</span>: <span class="hljs-string">`localhost:<span class="hljs-subst">${port}</span>`</span>
});

req.on(<span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">headers</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(headers[http2.constants.HTTP2_HEADER_STATUS]);
});
<span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;&#x27;</span>;
req.setEncoding(<span class="hljs-string">&#x27;utf8&#x27;</span>);
req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> data += chunk);
req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The server says: <span class="hljs-subst">${data}</span>`</span>);
  client.close();
});
req.end(<span class="hljs-string">&#x27;Jane&#x27;</span>);
</div></code></pre>
<h3 id="the-extended-connect-protocol">The extended <code>CONNECT</code> protocol</h3>
<p><a href="https://tools.ietf.org/html/rfc8441">RFC 8441</a> defines an &quot;Extended CONNECT Protocol&quot; extension to HTTP/2 that
may be used to bootstrap the use of an <code>Http2Stream</code> using the <code>CONNECT</code>
method as a tunnel for other communication protocols (such as WebSockets).</p>
<p>The use of the Extended CONNECT Protocol is enabled by HTTP/2 servers by using
the <code>enableConnectProtocol</code> setting:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> settings = { <span class="hljs-attr">enableConnectProtocol</span>: <span class="hljs-literal">true</span> };
<span class="hljs-keyword">const</span> server = http2.createServer({ settings });
</div></code></pre>
<p>Once the client receives the <code>SETTINGS</code> frame from the server indicating that
the extended CONNECT may be used, it may send <code>CONNECT</code> requests that use the
<code>':protocol'</code> HTTP/2 pseudo-header:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> client = http2.connect(<span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>);
client.on(<span class="hljs-string">&#x27;remoteSettings&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (settings.enableConnectProtocol) {
    <span class="hljs-keyword">const</span> req = client.request({ <span class="hljs-string">&#x27;:method&#x27;</span>: <span class="hljs-string">&#x27;CONNECT&#x27;</span>, <span class="hljs-string">&#x27;:protocol&#x27;</span>: <span class="hljs-string">&#x27;foo&#x27;</span> });
    <span class="hljs-comment">// ...</span>
  }
});
</div></code></pre>
<h2 id="compatibility-api">Compatibility API</h2>
<p>The Compatibility API has the goal of providing a similar developer experience
of HTTP/1 when using HTTP/2, making it possible to develop applications
that support both <a href="http.html">HTTP/1</a> and HTTP/2. This API targets only the
<strong>public API</strong> of the <a href="http.html">HTTP/1</a>. However many modules use internal
methods or state, and those <em>are not supported</em> as it is a completely
different implementation.</p>
<p>The following example creates an HTTP/2 server using the compatibility
API:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>);
  res.setHeader(<span class="hljs-string">&#x27;X-Foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);
  res.writeHead(<span class="hljs-number">200</span>, { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> });
  res.end(<span class="hljs-string">&#x27;ok&#x27;</span>);
});
</div></code></pre>
<p>In order to create a mixed <a href="https.html">HTTPS</a> and HTTP/2 server, refer to the
<a href="#alpn-negotiation">ALPN negotiation</a> section.
Upgrading from non-tls HTTP/1 servers is not supported.</p>
<p>The HTTP/2 compatibility API is composed of <a href="#class-http2http2serverrequest"><code>Http2ServerRequest</code></a> and
<a href="#class-http2http2serverresponse"><code>Http2ServerResponse</code></a>. They aim at API compatibility with HTTP/1, but
they do not hide the differences between the protocols. As an example,
the status message for HTTP codes is ignored.</p>
<h3 id="alpn-negotiation">ALPN negotiation</h3>
<p>ALPN negotiation allows supporting both <a href="https.html">HTTPS</a> and HTTP/2 over
the same socket. The <code>req</code> and <code>res</code> objects can be either HTTP/1 or
HTTP/2, and an application <strong>must</strong> restrict itself to the public API of
<a href="http.html">HTTP/1</a>, and detect if it is possible to use the more advanced
features of HTTP/2.</p>
<p>The following example creates a server that supports both protocols:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> { createSecureServer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> { readFileSync } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> cert = readFileSync(<span class="hljs-string">&#x27;./cert.pem&#x27;</span>);
<span class="hljs-keyword">const</span> key = readFileSync(<span class="hljs-string">&#x27;./key.pem&#x27;</span>);

<span class="hljs-keyword">const</span> server = createSecureServer(
  { cert, key, <span class="hljs-attr">allowHTTP1</span>: <span class="hljs-literal">true</span> },
  onRequest
).listen(<span class="hljs-number">4443</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRequest</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// Detects if it is a HTTPS request or HTTP/2</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">socket</span>: { alpnProtocol } } = req.httpVersion === <span class="hljs-string">&#x27;2.0&#x27;</span> ?
    req.stream.session : req;
  res.writeHead(<span class="hljs-number">200</span>, { <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> });
  res.end(<span class="hljs-built_in">JSON</span>.stringify({
    alpnProtocol,
    <span class="hljs-attr">httpVersion</span>: req.httpVersion
  }));
}
</div></code></pre>
<p>The <code>'request'</code> event works identically on both <a href="https.html">HTTPS</a> and
HTTP/2.</p>
<h3 id="class-http2http2serverrequest">Class: <code>http2.Http2ServerRequest</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {stream.Readable}</li>
</ul>
<p>A <code>Http2ServerRequest</code> object is created by <a href="#class-http2server"><code>http2.Server</code></a> or
<a href="#class-http2secureserver"><code>http2.SecureServer</code></a> and passed as the first argument to the
<a href="#event-request"><code>'request'</code></a> event. It may be used to access a request status, headers, and
data.</p>
<h4 id="event-aborted-1">Event: <code>'aborted'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>The <code>'aborted'</code> event is emitted whenever a <code>Http2ServerRequest</code> instance is
abnormally aborted in mid-communication.</p>
<p>The <code>'aborted'</code> event will only be emitted if the <code>Http2ServerRequest</code> writable
side has not been ended.</p>
<h4 id="event-close-2">Event: <code>'close'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Indicates that the underlying <a href="#class-http2stream"><code>Http2Stream</code></a> was closed.
Just like <code>'end'</code>, this event occurs only once per response.</p>
<h4 id="requestaborted"><code>request.aborted</code></h4>
<!-- YAML
added: v10.1.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>The <code>request.aborted</code> property will be <code>true</code> if the request has
been aborted.</p>
<h4 id="requestauthority"><code>request.authority</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>The request authority pseudo header field. Because HTTP/2 allows requests
to set either <code>:authority</code> or <code>host</code>, this value is derived from
<code>req.headers[':authority']</code> if present. Otherwise, it is derived from
<code>req.headers['host']</code>.</p>
<h4 id="requestcomplete"><code>request.complete</code></h4>
<!-- YAML
added: v12.10.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>The <code>request.complete</code> property will be <code>true</code> if the request has
been completed, aborted, or destroyed.</p>
<h4 id="requestconnection"><code>request.connection</code></h4>
<!-- YAML
added: v8.4.0
deprecated: v13.0.0
-->
<blockquote>
<p>Stability: 0 - Deprecated. Use <a href="#requestsocket"><code>request.socket</code></a>.</p>
</blockquote>
<ul>
<li>{net.Socket|tls.TLSSocket}</li>
</ul>
<p>See <a href="#requestsocket"><code>request.socket</code></a>.</p>
<h4 id="requestdestroyerror"><code>request.destroy([error])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>error</code> {Error}</li>
</ul>
<p>Calls <code>destroy()</code> on the <a href="#class-http2stream"><code>Http2Stream</code></a> that received
the <a href="#class-http2http2serverrequest"><code>Http2ServerRequest</code></a>. If <code>error</code> is provided, an <code>'error'</code> event
is emitted and <code>error</code> is passed as an argument to any listeners on the event.</p>
<p>It does nothing if the stream was already destroyed.</p>
<h4 id="requestheaders"><code>request.headers</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{Object}</li>
</ul>
<p>The request/response headers object.</p>
<p>Key-value pairs of header names and values. Header names are lower-cased.</p>
<pre><code class="language-js"><div><span class="hljs-comment">// Prints something like:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// { &#x27;user-agent&#x27;: &#x27;curl/7.22.0&#x27;,</span>
<span class="hljs-comment">//   host: &#x27;127.0.0.1:8000&#x27;,</span>
<span class="hljs-comment">//   accept: &#x27;*/*&#x27; }</span>
<span class="hljs-built_in">console</span>.log(request.headers);
</div></code></pre>
<p>See <a href="#headers-object">HTTP/2 Headers Object</a>.</p>
<p>In HTTP/2, the request path, host name, protocol, and method are represented as
special headers prefixed with the <code>:</code> character (e.g. <code>':path'</code>). These special
headers will be included in the <code>request.headers</code> object. Care must be taken not
to inadvertently modify these special headers or errors may occur. For instance,
removing all headers from the request will cause errors to occur:</p>
<pre><code class="language-js"><div>removeAllHeaders(request.headers);
assert(request.url);   <span class="hljs-comment">// Fails because the :path header has been removed</span>
</div></code></pre>
<h4 id="requesthttpversion"><code>request.httpVersion</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server. Returns
<code>'2.0'</code>.</p>
<p>Also <code>message.httpVersionMajor</code> is the first integer and
<code>message.httpVersionMinor</code> is the second.</p>
<h4 id="requestmethod"><code>request.method</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>The request method as a string. Read-only. Examples: <code>'GET'</code>, <code>'DELETE'</code>.</p>
<h4 id="requestrawheaders"><code>request.rawHeaders</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string[]}</li>
</ul>
<p>The raw request/response headers list exactly as they were received.</p>
<p>The keys and values are in the same list. It is <em>not</em> a
list of tuples. So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.</p>
<p>Header names are not lowercased, and duplicates are not merged.</p>
<pre><code class="language-js"><div><span class="hljs-comment">// Prints something like:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// [ &#x27;user-agent&#x27;,</span>
<span class="hljs-comment">//   &#x27;this is invalid because there can be only one&#x27;,</span>
<span class="hljs-comment">//   &#x27;User-Agent&#x27;,</span>
<span class="hljs-comment">//   &#x27;curl/7.22.0&#x27;,</span>
<span class="hljs-comment">//   &#x27;Host&#x27;,</span>
<span class="hljs-comment">//   &#x27;127.0.0.1:8000&#x27;,</span>
<span class="hljs-comment">//   &#x27;ACCEPT&#x27;,</span>
<span class="hljs-comment">//   &#x27;*/*&#x27; ]</span>
<span class="hljs-built_in">console</span>.log(request.rawHeaders);
</div></code></pre>
<h4 id="requestrawtrailers"><code>request.rawTrailers</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string[]}</li>
</ul>
<p>The raw request/response trailer keys and values exactly as they were
received. Only populated at the <code>'end'</code> event.</p>
<h4 id="requestscheme"><code>request.scheme</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>The request scheme pseudo header field indicating the scheme
portion of the target URL.</p>
<h4 id="requestsettimeoutmsecs-callback"><code>request.setTimeout(msecs, callback)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>msecs</code> {number}</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {http2.Http2ServerRequest}</li>
</ul>
<p>Sets the <a href="#class-http2stream"><code>Http2Stream</code></a>'s timeout value to <code>msecs</code>. If a callback is
provided, then it is added as a listener on the <code>'timeout'</code> event on
the response object.</p>
<p>If no <code>'timeout'</code> listener is added to the request, the response, or
the server, then <a href="#class-http2stream"><code>Http2Stream</code></a>s are destroyed when they time out. If a
handler is assigned to the request, the response, or the server's <code>'timeout'</code>
events, timed out sockets must be handled explicitly.</p>
<h4 id="requestsocket"><code>request.socket</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{net.Socket|tls.TLSSocket}</li>
</ul>
<p>Returns a <code>Proxy</code> object that acts as a <code>net.Socket</code> (or <code>tls.TLSSocket</code>) but
applies getters, setters, and methods based on HTTP/2 logic.</p>
<p><code>destroyed</code>, <code>readable</code>, and <code>writable</code> properties will be retrieved from and
set on <code>request.stream</code>.</p>
<p><code>destroy</code>, <code>emit</code>, <code>end</code>, <code>on</code> and <code>once</code> methods will be called on
<code>request.stream</code>.</p>
<p><code>setTimeout</code> method will be called on <code>request.stream.session</code>.</p>
<p><code>pause</code>, <code>read</code>, <code>resume</code>, and <code>write</code> will throw an error with code
<code>ERR_HTTP2_NO_SOCKET_MANIPULATION</code>. See <a href="#http2session-and-sockets"><code>Http2Session</code> and Sockets</a> for
more information.</p>
<p>All other interactions will be routed directly to the socket. With TLS support,
use <a href="tls.md#tlssocketgetpeercertificatedetailed"><code>request.socket.getPeerCertificate()</code></a> to obtain the client's
authentication details.</p>
<h4 id="requeststream"><code>request.stream</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{Http2Stream}</li>
</ul>
<p>The <a href="#class-http2stream"><code>Http2Stream</code></a> object backing the request.</p>
<h4 id="requesttrailers"><code>request.trailers</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{Object}</li>
</ul>
<p>The request/response trailers object. Only populated at the <code>'end'</code> event.</p>
<h4 id="requesturl"><code>request.url</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>Request URL string. This contains only the URL that is present in the actual
HTTP request. If the request is:</p>
<pre><code class="language-http"><div><span class="hljs-keyword">GET</span> <span class="hljs-string">/status?name=ryan</span> HTTP/1.1
<span class="hljs-attribute">Accept</span>: text/plain
</div></code></pre>
<p>Then <code>request.url</code> will be:</p>
<!-- eslint-disable semi -->
<pre><code class="language-js"><div><span class="hljs-string">&#x27;/status?name=ryan&#x27;</span>
</div></code></pre>
<p>To parse the url into its parts, <code>new URL()</code> can be used:</p>
<pre><code class="language-console"><div><span class="hljs-meta">$</span><span class="bash"> node</span>
<span class="hljs-meta">&gt;</span><span class="bash"> new URL(<span class="hljs-string">&#x27;/status?name=ryan&#x27;</span>, <span class="hljs-string">&#x27;http://example.com&#x27;</span>)</span>
URL {
  href: &#x27;http://example.com/status?name=ryan&#x27;,
  origin: &#x27;http://example.com&#x27;,
  protocol: &#x27;http:&#x27;,
  username: &#x27;&#x27;,
  password: &#x27;&#x27;,
  host: &#x27;example.com&#x27;,
  hostname: &#x27;example.com&#x27;,
  port: &#x27;&#x27;,
  pathname: &#x27;/status&#x27;,
  search: &#x27;?name=ryan&#x27;,
  searchParams: URLSearchParams { &#x27;name&#x27; =&gt; &#x27;ryan&#x27; },
  hash: &#x27;&#x27;
}
</div></code></pre>
<h3 id="class-http2http2serverresponse">Class: <code>http2.Http2ServerResponse</code></h3>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Extends: {Stream}</li>
</ul>
<p>This object is created internally by an HTTP server, not by the user. It is
passed as the second parameter to the <a href="#event-request"><code>'request'</code></a> event.</p>
<h4 id="event-close-3">Event: <code>'close'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Indicates that the underlying <a href="#class-http2stream"><code>Http2Stream</code></a> was terminated before
<a href="#responseenddata-encoding-callback"><code>response.end()</code></a> was called or able to flush.</p>
<h4 id="event-finish">Event: <code>'finish'</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Emitted when the response has been sent. More specifically, this event is
emitted when the last segment of the response headers and body have been
handed off to the HTTP/2 multiplexing for transmission over the network. It
does not imply that the client has received anything yet.</p>
<p>After this event, no more events will be emitted on the response object.</p>
<h4 id="responseaddtrailersheaders"><code>response.addTrailers(headers)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>headers</code> {Object}</li>
</ul>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.</p>
<p>Attempting to set a header field name or value that contains invalid characters
will result in a <a href="errors.md#class-typeerror"><code>TypeError</code></a> being thrown.</p>
<h4 id="responseconnection"><code>response.connection</code></h4>
<!-- YAML
added: v8.4.0
deprecated: v13.0.0
-->
<blockquote>
<p>Stability: 0 - Deprecated. Use <a href="#responsesocket"><code>response.socket</code></a>.</p>
</blockquote>
<ul>
<li>{net.Socket|tls.TLSSocket}</li>
</ul>
<p>See <a href="#responsesocket"><code>response.socket</code></a>.</p>
<h4 id="responsecreatepushresponseheaders-callback"><code>response.createPushResponse(headers, callback)</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41678
    description: Passing an invalid callback to the `callback` argument
                 now throws `ERR_INVALID_ARG_TYPE` instead of
                 `ERR_INVALID_CALLBACK`.
-->
<ul>
<li><code>headers</code> {HTTP/2 Headers Object} An object describing the headers</li>
<li><code>callback</code> {Function} Called once <code>http2stream.pushStream()</code> is finished,
or either when the attempt to create the pushed <code>Http2Stream</code> has failed or
has been rejected, or the state of <code>Http2ServerRequest</code> is closed prior to
calling the <code>http2stream.pushStream()</code> method
<ul>
<li><code>err</code> {Error}</li>
<li><code>res</code> {http2.Http2ServerResponse} The newly-created <code>Http2ServerResponse</code>
object</li>
</ul>
</li>
</ul>
<p>Call <a href="#http2streampushstreamheaders-options-callback"><code>http2stream.pushStream()</code></a> with the given headers, and wrap the
given <a href="#class-http2stream"><code>Http2Stream</code></a> on a newly created <code>Http2ServerResponse</code> as the callback
parameter if successful. When <code>Http2ServerRequest</code> is closed, the callback is
called with an error <code>ERR_HTTP2_INVALID_STREAM</code>.</p>
<h4 id="responseenddata-encoding-callback"><code>response.end([data[, encoding]][, callback])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18780
    description: This method now returns a reference to `ServerResponse`.
-->
<ul>
<li><code>data</code> {string|Buffer|Uint8Array}</li>
<li><code>encoding</code> {string}</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {this}</li>
</ul>
<p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each response.</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<a href="http.md#responsewritechunk-encoding-callback"><code>response.write(data, encoding)</code></a> followed by <code>response.end(callback)</code>.</p>
<p>If <code>callback</code> is specified, it will be called when the response stream
is finished.</p>
<h4 id="responsefinished"><code>response.finished</code></h4>
<!-- YAML
added: v8.4.0
deprecated:
 - v13.4.0
 - v12.16.0
-->
<blockquote>
<p>Stability: 0 - Deprecated. Use <a href="#responsewritableended"><code>response.writableEnded</code></a>.</p>
</blockquote>
<ul>
<li>{boolean}</li>
</ul>
<p>Boolean value that indicates whether the response has completed. Starts
as <code>false</code>. After <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> executes, the value will be <code>true</code>.</p>
<h4 id="responsegetheadername"><code>response.getHeader(name)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>name</code> {string}</li>
<li>Returns: {string}</li>
</ul>
<p>Reads out a header that has already been queued but not sent to the client.
The name is case-insensitive.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> contentType = response.getHeader(<span class="hljs-string">&#x27;content-type&#x27;</span>);
</div></code></pre>
<h4 id="responsegetheadernames"><code>response.getHeaderNames()</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Returns: {string[]}</li>
</ul>
<p>Returns an array containing the unique names of the current outgoing headers.
All header names are lowercase.</p>
<pre><code class="language-js"><div>response.setHeader(<span class="hljs-string">&#x27;Foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);
response.setHeader(<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>, [<span class="hljs-string">&#x27;foo=bar&#x27;</span>, <span class="hljs-string">&#x27;bar=baz&#x27;</span>]);

<span class="hljs-keyword">const</span> headerNames = response.getHeaderNames();
<span class="hljs-comment">// headerNames === [&#x27;foo&#x27;, &#x27;set-cookie&#x27;]</span>
</div></code></pre>
<h4 id="responsegetheaders"><code>response.getHeaders()</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>Returns: {Object}</li>
</ul>
<p>Returns a shallow copy of the current outgoing headers. Since a shallow copy
is used, array values may be mutated without additional calls to various
header-related http module methods. The keys of the returned object are the
header names and the values are the respective header values. All header names
are lowercase.</p>
<p>The object returned by the <code>response.getHeaders()</code> method <em>does not</em>
prototypically inherit from the JavaScript <code>Object</code>. This means that typical
<code>Object</code> methods such as <code>obj.toString()</code>, <code>obj.hasOwnProperty()</code>, and others
are not defined and <em>will not work</em>.</p>
<pre><code class="language-js"><div>response.setHeader(<span class="hljs-string">&#x27;Foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);
response.setHeader(<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>, [<span class="hljs-string">&#x27;foo=bar&#x27;</span>, <span class="hljs-string">&#x27;bar=baz&#x27;</span>]);

<span class="hljs-keyword">const</span> headers = response.getHeaders();
<span class="hljs-comment">// headers === { foo: &#x27;bar&#x27;, &#x27;set-cookie&#x27;: [&#x27;foo=bar&#x27;, &#x27;bar=baz&#x27;] }</span>
</div></code></pre>
<h4 id="responsehasheadername"><code>response.hasHeader(name)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>name</code> {string}</li>
<li>Returns: {boolean}</li>
</ul>
<p>Returns <code>true</code> if the header identified by <code>name</code> is currently set in the
outgoing headers. The header name matching is case-insensitive.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> hasContentType = response.hasHeader(<span class="hljs-string">&#x27;content-type&#x27;</span>);
</div></code></pre>
<h4 id="responseheaderssent"><code>response.headersSent</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>True if headers were sent, false otherwise (read-only).</p>
<h4 id="responseremoveheadername"><code>response.removeHeader(name)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>name</code> {string}</li>
</ul>
<p>Removes a header that has been queued for implicit sending.</p>
<pre><code class="language-js"><div>response.removeHeader(<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>);
</div></code></pre>
<h3 id="responsereq"><code>response.req</code></h3>
<!-- YAML
added: v15.7.0
-->
<ul>
<li>{http2.Http2ServerRequest}</li>
</ul>
<p>A reference to the original HTTP2 <code>request</code> object.</p>
<h4 id="responsesenddate"><code>response.sendDate</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.</p>
<p>This should only be disabled for testing; HTTP requires the Date header
in responses.</p>
<h4 id="responsesetheadername-value"><code>response.setHeader(name, value)</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>name</code> {string}</li>
<li><code>value</code> {string|string[]}</li>
</ul>
<p>Sets a single header value for implicit headers. If this header already exists
in the to-be-sent headers, its value will be replaced. Use an array of strings
here to send multiple headers with the same name.</p>
<pre><code class="language-js"><div>response.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>);
</div></code></pre>
<p>or</p>
<pre><code class="language-js"><div>response.setHeader(<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>, [<span class="hljs-string">&#x27;type=ninja&#x27;</span>, <span class="hljs-string">&#x27;language=javascript&#x27;</span>]);
</div></code></pre>
<p>Attempting to set a header field name or value that contains invalid characters
will result in a <a href="errors.md#class-typeerror"><code>TypeError</code></a> being thrown.</p>
<p>When headers have been set with <a href="#responsesetheadername-value"><code>response.setHeader()</code></a>, they will be merged
with any headers passed to <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a>, with the headers passed
to <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> given precedence.</p>
<pre><code class="language-js"><div><span class="hljs-comment">// Returns content-type = text/plain</span>
<span class="hljs-keyword">const</span> server = http2.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>);
  res.setHeader(<span class="hljs-string">&#x27;X-Foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);
  res.writeHead(<span class="hljs-number">200</span>, { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> });
  res.end(<span class="hljs-string">&#x27;ok&#x27;</span>);
});
</div></code></pre>
<h4 id="responsesettimeoutmsecs-callback"><code>response.setTimeout(msecs[, callback])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>msecs</code> {number}</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {http2.Http2ServerResponse}</li>
</ul>
<p>Sets the <a href="#class-http2stream"><code>Http2Stream</code></a>'s timeout value to <code>msecs</code>. If a callback is
provided, then it is added as a listener on the <code>'timeout'</code> event on
the response object.</p>
<p>If no <code>'timeout'</code> listener is added to the request, the response, or
the server, then <a href="#class-http2stream"><code>Http2Stream</code></a>s are destroyed when they time out. If a
handler is assigned to the request, the response, or the server's <code>'timeout'</code>
events, timed out sockets must be handled explicitly.</p>
<h4 id="responsesocket"><code>response.socket</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{net.Socket|tls.TLSSocket}</li>
</ul>
<p>Returns a <code>Proxy</code> object that acts as a <code>net.Socket</code> (or <code>tls.TLSSocket</code>) but
applies getters, setters, and methods based on HTTP/2 logic.</p>
<p><code>destroyed</code>, <code>readable</code>, and <code>writable</code> properties will be retrieved from and
set on <code>response.stream</code>.</p>
<p><code>destroy</code>, <code>emit</code>, <code>end</code>, <code>on</code> and <code>once</code> methods will be called on
<code>response.stream</code>.</p>
<p><code>setTimeout</code> method will be called on <code>response.stream.session</code>.</p>
<p><code>pause</code>, <code>read</code>, <code>resume</code>, and <code>write</code> will throw an error with code
<code>ERR_HTTP2_NO_SOCKET_MANIPULATION</code>. See <a href="#http2session-and-sockets"><code>Http2Session</code> and Sockets</a> for
more information.</p>
<p>All other interactions will be routed directly to the socket.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);
<span class="hljs-keyword">const</span> server = http2.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> ip = req.socket.remoteAddress;
  <span class="hljs-keyword">const</span> port = req.socket.remotePort;
  res.end(<span class="hljs-string">`Your IP address is <span class="hljs-subst">${ip}</span> and your source port is <span class="hljs-subst">${port}</span>.`</span>);
}).listen(<span class="hljs-number">3000</span>);
</div></code></pre>
<h4 id="responsestatuscode"><code>response.statusCode</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{number}</li>
</ul>
<p>When using implicit headers (not calling <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> explicitly),
this property controls the status code that will be sent to the client when
the headers get flushed.</p>
<pre><code class="language-js"><div>response.statusCode = <span class="hljs-number">404</span>;
</div></code></pre>
<p>After response header was sent to the client, this property indicates the
status code which was sent out.</p>
<h4 id="responsestatusmessage"><code>response.statusMessage</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{string}</li>
</ul>
<p>Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
an empty string.</p>
<h4 id="responsestream"><code>response.stream</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li>{Http2Stream}</li>
</ul>
<p>The <a href="#class-http2stream"><code>Http2Stream</code></a> object backing the response.</p>
<h4 id="responsewritableended"><code>response.writableEnded</code></h4>
<!-- YAML
added: v12.9.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> after <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> has been called. This property
does not indicate whether the data has been flushed, for this use
<a href="stream.md#writablewritablefinished"><code>writable.writableFinished</code></a> instead.</p>
<h4 id="responsewritechunk-encoding"><code>response.write(chunk[, encoding][, callback])</code></h4>
<!-- YAML
added: v8.4.0
-->
<ul>
<li><code>chunk</code> {string|Buffer|Uint8Array}</li>
<li><code>encoding</code> {string}</li>
<li><code>callback</code> {Function}</li>
<li>Returns: {boolean}</li>
</ul>
<p>If this method is called and <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> has not been called,
it will switch to implicit header mode and flush the implicit headers.</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.</p>
<p>In the <code>http</code> module, the response body is omitted when the
request is a HEAD request. Similarly, the <code>204</code> and <code>304</code> responses
<em>must not</em> include a message body.</p>
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>'utf8'</code>. <code>callback</code> will be called when this chunk
of data is flushed.</p>
<p>This is the raw HTTP body and has nothing to do with higher-level multi-part
body encodings that may be used.</p>
<p>The first time <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> is called, it will send the buffered
header information and the first chunk of the body to the client. The second
time <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> is called, Node.js assumes data will be streamed,
and sends the new data separately. That is, the response is buffered up to the
first chunk of the body.</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is free again.</p>
<h4 id="responsewritecontinue"><code>response.writeContinue()</code></h4>
<!-- YAML
added: v8.4.0
-->
<p>Sends a status <code>100 Continue</code> to the client, indicating that the request body
should be sent. See the <a href="#event-checkcontinue"><code>'checkContinue'</code></a> event on <code>Http2Server</code> and
<code>Http2SecureServer</code>.</p>
<h4 id="responsewriteheadstatuscode-statusmessage"><code>response.writeHead(statusCode[, statusMessage][, headers])</code></h4>
<!-- YAML
added: v8.4.0
changes:
  - version:
     - v11.10.0
     - v10.17.0
    pr-url: https://github.com/nodejs/node/pull/25974
    description: Return `this` from `writeHead()` to allow chaining with
                 `end()`.
-->
<ul>
<li><code>statusCode</code> {number}</li>
<li><code>statusMessage</code> {string}</li>
<li><code>headers</code> {Object}</li>
<li>Returns: {http2.Http2ServerResponse}</li>
</ul>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.</p>
<p>Returns a reference to the <code>Http2ServerResponse</code>, so that calls can be chained.</p>
<p>For compatibility with <a href="http.html">HTTP/1</a>, a human-readable <code>statusMessage</code> may be
passed as the second argument. However, because the <code>statusMessage</code> has no
meaning within HTTP/2, the argument will have no effect and a process warning
will be emitted.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> body = <span class="hljs-string">&#x27;hello world&#x27;</span>;
response.writeHead(<span class="hljs-number">200</span>, {
  <span class="hljs-string">&#x27;Content-Length&#x27;</span>: Buffer.byteLength(body),
  <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>,
});
</div></code></pre>
<p><code>Content-Length</code> is given in bytes not characters. The
<code>Buffer.byteLength()</code> API may be used to determine the number of bytes in a
given encoding. On outbound messages, Node.js does not check if Content-Length
and the length of the body being transmitted are equal or not. However, when
receiving messages, Node.js will automatically reject messages when the
<code>Content-Length</code> does not match the actual payload size.</p>
<p>This method may be called at most one time on a message before
<a href="#responseenddata-encoding-callback"><code>response.end()</code></a> is called.</p>
<p>If <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> or <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> are called before calling
this, the implicit/mutable headers will be calculated and call this function.</p>
<p>When headers have been set with <a href="#responsesetheadername-value"><code>response.setHeader()</code></a>, they will be merged
with any headers passed to <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a>, with the headers passed
to <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> given precedence.</p>
<pre><code class="language-js"><div><span class="hljs-comment">// Returns content-type = text/plain</span>
<span class="hljs-keyword">const</span> server = http2.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>);
  res.setHeader(<span class="hljs-string">&#x27;X-Foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);
  res.writeHead(<span class="hljs-number">200</span>, { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span> });
  res.end(<span class="hljs-string">&#x27;ok&#x27;</span>);
});
</div></code></pre>
<p>Attempting to set a header field name or value that contains invalid characters
will result in a <a href="errors.md#class-typeerror"><code>TypeError</code></a> being thrown.</p>
<h2 id="collecting-http2-performance-metrics">Collecting HTTP/2 performance metrics</h2>
<p>The <a href="perf_hooks.html">Performance Observer</a> API can be used to collect basic performance
metrics for each <code>Http2Session</code> and <code>Http2Stream</code> instance.</p>
<pre><code class="language-js"><div><span class="hljs-keyword">const</span> { PerformanceObserver } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perf_hooks&#x27;</span>);

<span class="hljs-keyword">const</span> obs = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function">(<span class="hljs-params">items</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> entry = items.getEntries()[<span class="hljs-number">0</span>];
  <span class="hljs-built_in">console</span>.log(entry.entryType);  <span class="hljs-comment">// prints &#x27;http2&#x27;</span>
  <span class="hljs-keyword">if</span> (entry.name === <span class="hljs-string">&#x27;Http2Session&#x27;</span>) {
    <span class="hljs-comment">// Entry contains statistics about the Http2Session</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.name === <span class="hljs-string">&#x27;Http2Stream&#x27;</span>) {
    <span class="hljs-comment">// Entry contains statistics about the Http2Stream</span>
  }
});
obs.observe({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&#x27;http2&#x27;</span>] });
</div></code></pre>
<p>The <code>entryType</code> property of the <code>PerformanceEntry</code> will be equal to <code>'http2'</code>.</p>
<p>The <code>name</code> property of the <code>PerformanceEntry</code> will be equal to either
<code>'Http2Stream'</code> or <code>'Http2Session'</code>.</p>
<p>If <code>name</code> is equal to <code>Http2Stream</code>, the <code>PerformanceEntry</code> will contain the
following additional properties:</p>
<ul>
<li><code>bytesRead</code> {number} The number of <code>DATA</code> frame bytes received for this
<code>Http2Stream</code>.</li>
<li><code>bytesWritten</code> {number} The number of <code>DATA</code> frame bytes sent for this
<code>Http2Stream</code>.</li>
<li><code>id</code> {number} The identifier of the associated <code>Http2Stream</code></li>
<li><code>timeToFirstByte</code> {number} The number of milliseconds elapsed between the
<code>PerformanceEntry</code> <code>startTime</code> and the reception of the first <code>DATA</code> frame.</li>
<li><code>timeToFirstByteSent</code> {number} The number of milliseconds elapsed between
the <code>PerformanceEntry</code> <code>startTime</code> and sending of the first <code>DATA</code> frame.</li>
<li><code>timeToFirstHeader</code> {number} The number of milliseconds elapsed between the
<code>PerformanceEntry</code> <code>startTime</code> and the reception of the first header.</li>
</ul>
<p>If <code>name</code> is equal to <code>Http2Session</code>, the <code>PerformanceEntry</code> will contain the
following additional properties:</p>
<ul>
<li><code>bytesRead</code> {number} The number of bytes received for this <code>Http2Session</code>.</li>
<li><code>bytesWritten</code> {number} The number of bytes sent for this <code>Http2Session</code>.</li>
<li><code>framesReceived</code> {number} The number of HTTP/2 frames received by the
<code>Http2Session</code>.</li>
<li><code>framesSent</code> {number} The number of HTTP/2 frames sent by the <code>Http2Session</code>.</li>
<li><code>maxConcurrentStreams</code> {number} The maximum number of streams concurrently
open during the lifetime of the <code>Http2Session</code>.</li>
<li><code>pingRTT</code> {number} The number of milliseconds elapsed since the transmission
of a <code>PING</code> frame and the reception of its acknowledgment. Only present if
a <code>PING</code> frame has been sent on the <code>Http2Session</code>.</li>
<li><code>streamAverageDuration</code> {number} The average duration (in milliseconds) for
all <code>Http2Stream</code> instances.</li>
<li><code>streamCount</code> {number} The number of <code>Http2Stream</code> instances processed by
the <code>Http2Session</code>.</li>
<li><code>type</code> {string} Either <code>'server'</code> or <code>'client'</code> to identify the type of
<code>Http2Session</code>.</li>
</ul>
<h2 id="note-on-authority-and-host">Note on <code>:authority</code> and <code>host</code></h2>
<p>HTTP/2 requires requests to have either the <code>:authority</code> pseudo-header
or the <code>host</code> header. Prefer <code>:authority</code> when constructing an HTTP/2
request directly, and <code>host</code> when converting from HTTP/1 (in proxies,
for instance).</p>
<p>The compatibility API falls back to <code>host</code> if <code>:authority</code> is not
present. See <a href="#requestauthority"><code>request.authority</code></a> for more information. However,
if you don't use the compatibility API (or use <code>req.headers</code> directly),
you need to implement any fall-back behavior yourself.</p>

    </body>
    </html>