<!DOCTYPE html>
<html>
<button onclick="history.back()" id="BACKBUTTON">Back</button>
<link rel="stylesheet" href="../css/default.css" />

<head>
  <meta charset="UTF-8">
  <title>Assert</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
      font-size: 14px;
      line-height: 1.6;
    }
  </style>
  <style>
    .task-list-item {
      list-style-type: none;
    }

    .task-list-item-checkbox {
      margin-left: -20px;
      vertical-align: middle;
    }
  </style>
</head>

<body>
  <h1 id="assert">Assert</h1>
  <!--introduced_in=v0.1.21-->
  <blockquote>
    <p>Stability: 2 - Stable</p>
  </blockquote>
  <!-- source_link=lib/assert.js -->
  <p>The <code>assert</code> module provides a set of assertion functions for verifying
    invariants.</p>
  <h2 id="strict-assertion-mode">Strict assertion mode</h2>
  <!-- YAML
added: v9.9.0
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34001
    description: Exposed as `require('assert/strict')`.
  - version:
      - v13.9.0
      - v12.16.2
    pr-url: https://github.com/nodejs/node/pull/31635
    description: Changed "strict mode" to "strict assertion mode" and "legacy
                 mode" to "legacy assertion mode" to avoid confusion with the
                 more usual meaning of "strict mode".
  - version: v9.9.0
    pr-url: https://github.com/nodejs/node/pull/17615
    description: Added error diffs to the strict assertion mode.
  - version: v9.9.0
    pr-url: https://github.com/nodejs/node/pull/17002
    description: Added strict assertion mode to the assert module.
-->
  <p>In strict assertion mode, non-strict methods behave like their corresponding
    strict methods. For example, <a href="#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a>
    will behave like
    <a href="#assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual()</code></a>.</p>
  <p>In strict assertion mode, error messages for objects display a diff. In legacy
    assertion mode, error messages for objects display the objects, often truncated.</p>
  <p>To use strict assertion mode:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> { strict <span class="hljs-keyword">as</span> assert } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>).strict;
</div></code></pre>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);
</div></code></pre>
  <p>Example error diff:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> { strict <span class="hljs-keyword">as</span> assert } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

assert.deepEqual([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>]], <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected ... Lines skipped</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   [</span>
<span class="hljs-comment">//     [</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//       2,</span>
<span class="hljs-comment">// +     3</span>
<span class="hljs-comment">// -     &#x27;3&#x27;</span>
<span class="hljs-comment">//     ],</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//     5</span>
<span class="hljs-comment">//   ]</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.deepEqual([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>]], <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected ... Lines skipped</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   [</span>
<span class="hljs-comment">//     [</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//       2,</span>
<span class="hljs-comment">// +     3</span>
<span class="hljs-comment">// -     &#x27;3&#x27;</span>
<span class="hljs-comment">//     ],</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//     5</span>
<span class="hljs-comment">//   ]</span>
</div></code></pre>
  <p>To deactivate the colors, use the <code>NO_COLOR</code> or <code>NODE_DISABLE_COLORS</code>
    environment variables. This will also deactivate the colors in the REPL. For
    more on color support in terminal environments, read the tty
    <a href="tty.md#writestreamgetcolordepthenv"><code>getColorDepth()</code></a> documentation.</p>
  <h2 id="legacy-assertion-mode">Legacy assertion mode</h2>
  <p>Legacy assertion mode uses the <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code>
      operator</a> in:</p>
  <ul>
    <li><a href="#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a></li>
    <li><a href="#assertequalactual-expected-message"><code>assert.equal()</code></a></li>
    <li><a href="#assertnotdeepequalactual-expected-message"><code>assert.notDeepEqual()</code></a></li>
    <li><a href="#assertnotequalactual-expected-message"><code>assert.notEqual()</code></a></li>
  </ul>
  <p>To use legacy assertion mode:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);
</div></code></pre>
  <p>Legacy assertion mode may have surprising results, especially when using
    <a href="#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a>:</p>
  <pre><code class="language-cjs"><div><span class="hljs-comment">// WARNING: This does not throw an AssertionError in legacy assertion mode!</span>
assert.deepEqual(<span class="hljs-regexp">/a/gi</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
</div></code></pre>
  <h2 id="class-assertassertionerror">Class: assert.AssertionError</h2>
  <ul>
    <li>Extends: {errors.Error}</li>
  </ul>
  <p>Indicates the failure of an assertion. All errors thrown by the <code>assert</code> module
    will be instances of the <code>AssertionError</code> class.</p>
  <h3 id="new-assertassertionerroroptions"><code>new assert.AssertionError(options)</code></h3>
  <!-- YAML
added: v0.1.21
-->
  <ul>
    <li><code>options</code> {Object}
      <ul>
        <li><code>message</code> {string} If provided, the error message is set to this value.</li>
        <li><code>actual</code> {any} The <code>actual</code> property on the error instance.</li>
        <li><code>expected</code> {any} The <code>expected</code> property on the error instance.</li>
        <li><code>operator</code> {string} The <code>operator</code> property on the error instance.</li>
        <li><code>stackStartFn</code> {Function} If provided, the generated stack trace omits
          frames before this function.</li>
      </ul>
    </li>
  </ul>
  <p>A subclass of <code>Error</code> that indicates the failure of an assertion.</p>
  <p>All instances contain the built-in <code>Error</code> properties (<code>message</code> and <code>name</code>)
    and:</p>
  <ul>
    <li><code>actual</code> {any} Set to the <code>actual</code> argument for methods such as
      <a href="#assertstrictequalactual-expected-message"><code>assert.strictEqual()</code></a>.</li>
    <li><code>expected</code> {any} Set to the <code>expected</code> value for methods such as
      <a href="#assertstrictequalactual-expected-message"><code>assert.strictEqual()</code></a>.</li>
    <li><code>generatedMessage</code> {boolean} Indicates if the message was auto-generated
      (<code>true</code>) or not.</li>
    <li><code>code</code> {string} Value is always <code>ERR_ASSERTION</code> to show that the error is an
      assertion error.</li>
    <li><code>operator</code> {string} Set to the passed in operator value.</li>
  </ul>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-comment">// Generate an AssertionError to compare the error message later:</span>
<span class="hljs-keyword">const</span> { message } = <span class="hljs-keyword">new</span> assert.AssertionError({
  <span class="hljs-attr">actual</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">expected</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;strictEqual&#x27;</span>
});

<span class="hljs-comment">// Verify error output:</span>
<span class="hljs-keyword">try</span> {
  assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
} <span class="hljs-keyword">catch</span> (err) {
  assert(err <span class="hljs-keyword">instanceof</span> assert.AssertionError);
  assert.strictEqual(err.message, message);
  assert.strictEqual(err.name, <span class="hljs-string">&#x27;AssertionError&#x27;</span>);
  assert.strictEqual(err.actual, <span class="hljs-number">1</span>);
  assert.strictEqual(err.expected, <span class="hljs-number">2</span>);
  assert.strictEqual(err.code, <span class="hljs-string">&#x27;ERR_ASSERTION&#x27;</span>);
  assert.strictEqual(err.operator, <span class="hljs-string">&#x27;strictEqual&#x27;</span>);
  assert.strictEqual(err.generatedMessage, <span class="hljs-literal">true</span>);
}
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-comment">// Generate an AssertionError to compare the error message later:</span>
<span class="hljs-keyword">const</span> { message } = <span class="hljs-keyword">new</span> assert.AssertionError({
  <span class="hljs-attr">actual</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">expected</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;strictEqual&#x27;</span>
});

<span class="hljs-comment">// Verify error output:</span>
<span class="hljs-keyword">try</span> {
  assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
} <span class="hljs-keyword">catch</span> (err) {
  assert(err <span class="hljs-keyword">instanceof</span> assert.AssertionError);
  assert.strictEqual(err.message, message);
  assert.strictEqual(err.name, <span class="hljs-string">&#x27;AssertionError&#x27;</span>);
  assert.strictEqual(err.actual, <span class="hljs-number">1</span>);
  assert.strictEqual(err.expected, <span class="hljs-number">2</span>);
  assert.strictEqual(err.code, <span class="hljs-string">&#x27;ERR_ASSERTION&#x27;</span>);
  assert.strictEqual(err.operator, <span class="hljs-string">&#x27;strictEqual&#x27;</span>);
  assert.strictEqual(err.generatedMessage, <span class="hljs-literal">true</span>);
}
</div></code></pre>
  <h2 id="class-assertcalltracker">Class: <code>assert.CallTracker</code></h2>
  <!-- YAML
added:
  - v14.2.0
  - v12.19.0
-->
  <blockquote>
    <p>Stability: 1 - Experimental</p>
  </blockquote>
  <p>This feature is currently experimental and behavior might still change.</p>
  <h3 id="new-assertcalltracker"><code>new assert.CallTracker()</code></h3>
  <!-- YAML
added:
  - v14.2.0
  - v12.19.0
-->
  <p>Creates a new <a href="#class-assertcalltracker"><code>CallTracker</code></a> object which can be used to track if
    functions
    were called a specific number of times. The <code>tracker.verify()</code> must be called
    for the verification to take place. The usual pattern would be to call it in a
    <a href="process.md#event-exit"><code>process.on('exit')</code></a> handler.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;
<span class="hljs-keyword">import</span> process <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;process&#x27;</span>;

<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// callsfunc() must be called exactly 1 time before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">1</span>);

callsfunc();

<span class="hljs-comment">// Calls tracker.verify() and verifies if all tracker.calls() functions have</span>
<span class="hljs-comment">// been called exact times.</span>
process.on(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  tracker.verify();
});
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// callsfunc() must be called exactly 1 time before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">1</span>);

callsfunc();

<span class="hljs-comment">// Calls tracker.verify() and verifies if all tracker.calls() functions have</span>
<span class="hljs-comment">// been called exact times.</span>
process.on(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  tracker.verify();
});
</div></code></pre>
  <h3 id="trackercallsfn"><code>tracker.calls([fn][, exact])</code></h3>
  <!-- YAML
added:
  - v14.2.0
  - v12.19.0
-->
  <ul>
    <li><code>fn</code> {Function} <strong>Default:</strong> A no-op function.</li>
    <li><code>exact</code> {number} <strong>Default:</strong> <code>1</code>.</li>
    <li>Returns: {Function} that wraps <code>fn</code>.</li>
  </ul>
  <p>The wrapper function is expected to be called exactly <code>exact</code> times. If the
    function has not been called exactly <code>exact</code> times when
    <a href="#trackerverify"><code>tracker.verify()</code></a> is called, then <a
      href="#trackerverify"><code>tracker.verify()</code></a> will throw an
    error.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func);
</div></code></pre>
  <h3 id="trackerreport"><code>tracker.report()</code></h3>
  <!-- YAML
added:
  - v14.2.0
  - v12.19.0
-->
  <ul>
    <li>Returns: {Array} of objects containing information about the wrapper functions
      returned by <a href="#trackercallsfn-exact"><code>tracker.calls()</code></a>.</li>
    <li>Object {Object}
      <ul>
        <li><code>message</code> {string}</li>
        <li><code>actual</code> {number} The actual number of times the function was called.</li>
        <li><code>expected</code> {number} The number of times the function was expected to be
          called.</li>
        <li><code>operator</code> {string} The name of the function that is wrapped.</li>
        <li><code>stack</code> {Object} A stack trace of the function.</li>
      </ul>
    </li>
  </ul>
  <p>The arrays contains information about the expected and actual number of calls of
    the functions that have not been called the expected number of times.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Returns an array containing information on callsfunc()</span>
tracker.report();
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//  {</span>
<span class="hljs-comment">//    message: &#x27;Expected the func function to be executed 2 time(s) but was</span>
<span class="hljs-comment">//    executed 0 time(s).&#x27;,</span>
<span class="hljs-comment">//    actual: 0,</span>
<span class="hljs-comment">//    expected: 2,</span>
<span class="hljs-comment">//    operator: &#x27;func&#x27;,</span>
<span class="hljs-comment">//    stack: stack trace</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">// ]</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Returns an array containing information on callsfunc()</span>
tracker.report();
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//  {</span>
<span class="hljs-comment">//    message: &#x27;Expected the func function to be executed 2 time(s) but was</span>
<span class="hljs-comment">//    executed 0 time(s).&#x27;,</span>
<span class="hljs-comment">//    actual: 0,</span>
<span class="hljs-comment">//    expected: 2,</span>
<span class="hljs-comment">//    operator: &#x27;func&#x27;,</span>
<span class="hljs-comment">//    stack: stack trace</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">// ]</span>
</div></code></pre>
  <h3 id="trackerverify"><code>tracker.verify()</code></h3>
  <!-- YAML
added:
  - v14.2.0
  - v12.19.0
-->
  <p>Iterates through the list of functions passed to
    <a href="#trackercallsfn-exact"><code>tracker.calls()</code></a> and will throw an error for functions that
    have not been called the expected number of times.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">2</span>);

callsfunc();

<span class="hljs-comment">// Will throw an error since callsfunc() was only called once.</span>
tracker.verify();
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-comment">// Creates call tracker.</span>
<span class="hljs-keyword">const</span> tracker = <span class="hljs-keyword">new</span> assert.CallTracker();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// Returns a function that wraps func() that must be called exact times</span>
<span class="hljs-comment">// before tracker.verify().</span>
<span class="hljs-keyword">const</span> callsfunc = tracker.calls(func, <span class="hljs-number">2</span>);

callsfunc();

<span class="hljs-comment">// Will throw an error since callsfunc() was only called once.</span>
tracker.verify();
</div></code></pre>
  <h2 id="assertvalue-message"><code>assert(value[, message])</code></h2>
  <!-- YAML
added: v0.5.9
-->
  <ul>
    <li><code>value</code> {any} The input that is checked for being truthy.</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>An alias of <a href="#assertokvalue-message"><code>assert.ok()</code></a>.</p>
  <h2 id="assertdeepequalactual-expected-message"><code>assert.deepEqual(actual, expected[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41020
    description: Regular expressions lastIndex property is now compared as well.
  - version:
      - v16.0.0
      - v14.18.0
    pr-url: https://github.com/nodejs/node/pull/38113
    description: In Legacy assertion mode, changed status from Deprecated to
                 Legacy.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30766
    description: NaN is now treated as being identical if both sides are
                 NaN.
  - version: v12.0.0
    pr-url: https://github.com/nodejs/node/pull/25008
    description: The type tags are now properly compared and there are a couple
                 minor comparison adjustments to make the check less surprising.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15001
    description: The `Error` names and messages are now properly compared.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12142
    description: The `Set` and `Map` content is also compared.
  - version:
      - v6.4.0
      - v4.7.1
    pr-url: https://github.com/nodejs/node/pull/8002
    description: Typed array slices are handled correctly now.
  - version:
      - v6.1.0
      - v4.5.0
    pr-url: https://github.com/nodejs/node/pull/6432
    description: Objects with circular references can be used as inputs now.
  - version:
      - v5.10.1
      - v4.4.3
    pr-url: https://github.com/nodejs/node/pull/5910
    description: Handle non-`Uint8Array` typed arrays correctly.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p><strong>Strict assertion mode</strong></p>
  <p>An alias of <a href="#assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual()</code></a>.</p>
  <p><strong>Legacy assertion mode</strong></p>
  <blockquote>
    <p>Stability: 3 - Legacy: Use <a
        href="#assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual()</code></a> instead.</p>
  </blockquote>
  <p>Tests for deep equality between the <code>actual</code> and <code>expected</code> parameters. Consider
    using <a href="#assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual()</code></a> instead. <a
      href="#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a> can have
    surprising results.</p>
  <p><em>Deep equality</em> means that the enumerable &quot;own&quot; properties of child objects
    are also recursively evaluated by the following rules.</p>
  <h3 id="comparison-details">Comparison details</h3>
  <ul>
    <li>Primitive values are compared with the <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code>
        operator</a>,
      with the exception of <code>NaN</code>. It is treated as being identical in case
      both sides are <code>NaN</code>.</li>
    <li><a href="https://tc39.github.io/ecma262/#sec-object.prototype.tostring">Type tags</a> of objects should be the
      same.</li>
    <li>Only <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">enumerable
        &quot;own&quot; properties</a> are considered.</li>
    <li><a href="errors.md#class-error"><code>Error</code></a> names and messages are always compared, even if these are
      not
      enumerable properties.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive#Primitive_wrapper_objects_in_JavaScript">Object
        wrappers</a> are compared both as objects and unwrapped values.</li>
    <li><code>Object</code> properties are compared unordered.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>
      keys and <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>
      items are compared unordered.</li>
    <li>Recursion stops when both sides differ or both sides encounter a circular
      reference.</li>
    <li>Implementation does not test the <a
        href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots"><code>[[Prototype]]</code></a>
      of
      objects.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>
      properties are not compared.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><code>WeakMap</code></a>
      and <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a>
      comparison does not rely on their values.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>
      lastIndex, flags and source are always compared, even if these
      are not enumerable properties.</li>
  </ul>
  <p>The following example does not throw an <a href="#class-assertassertionerror"><code>AssertionError</code></a>
    because the
    primitives are compared using the <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code>
      operator</a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;
<span class="hljs-comment">// WARNING: This does not throw an AssertionError!</span>

assert.deepEqual(<span class="hljs-string">&#x27;+00000000&#x27;</span>, <span class="hljs-literal">false</span>);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);
<span class="hljs-comment">// WARNING: This does not throw an AssertionError!</span>

assert.deepEqual(<span class="hljs-string">&#x27;+00000000&#x27;</span>, <span class="hljs-literal">false</span>);
</div></code></pre>
  <p>&quot;Deep&quot; equality means that the enumerable &quot;own&quot; properties of child objects
    are evaluated also:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-keyword">const</span> obj1 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>
  }
};
<span class="hljs-keyword">const</span> obj3 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj4 = <span class="hljs-built_in">Object</span>.create(obj1);

assert.deepEqual(obj1, obj1);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Values of b are different:</span>
assert.deepEqual(obj1, obj2);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }</span>

assert.deepEqual(obj1, obj3);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Prototypes are ignored:</span>
assert.deepEqual(obj1, obj4);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } deepEqual {}</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-keyword">const</span> obj1 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>
  }
};
<span class="hljs-keyword">const</span> obj3 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj4 = <span class="hljs-built_in">Object</span>.create(obj1);

assert.deepEqual(obj1, obj1);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Values of b are different:</span>
assert.deepEqual(obj1, obj2);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }</span>

assert.deepEqual(obj1, obj3);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Prototypes are ignored:</span>
assert.deepEqual(obj1, obj4);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } deepEqual {}</span>
</div></code></pre>
  <p>If the values are not equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown
    with a <code>message</code>
    property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
    parameter is undefined, a default error message is assigned. If the <code>message</code>
    parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead
    of the
    <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <h2 id="assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual(actual, expected[, message])</code>
  </h2>
  <!-- YAML
added: v1.2.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/41020
    description: Regular expressions lastIndex property is now compared as well.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15169
    description: Enumerable symbol properties are now compared.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15036
    description: The `NaN` is now compared using the
              [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero)
              comparison.
  - version: v8.5.0
    pr-url: https://github.com/nodejs/node/pull/15001
    description: The `Error` names and messages are now properly compared.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12142
    description: The `Set` and `Map` content is also compared.
  - version:
    - v6.4.0
    - v4.7.1
    pr-url: https://github.com/nodejs/node/pull/8002
    description: Typed array slices are handled correctly now.
  - version: v6.1.0
    pr-url: https://github.com/nodejs/node/pull/6432
    description: Objects with circular references can be used as inputs now.
  - version:
    - v5.10.1
    - v4.4.3
    pr-url: https://github.com/nodejs/node/pull/5910
    description: Handle non-`Uint8Array` typed arrays correctly.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Tests for deep equality between the <code>actual</code> and <code>expected</code> parameters.
    &quot;Deep&quot; equality means that the enumerable &quot;own&quot; properties of child objects
    are recursively evaluated also by the following rules.</p>
  <h3 id="comparison-details-1">Comparison details</h3>
  <ul>
    <li>Primitive values are compared using <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a>.
    </li>
    <li><a href="https://tc39.github.io/ecma262/#sec-object.prototype.tostring">Type tags</a> of objects should be the
      same.</li>
    <li><a
        href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots"><code>[[Prototype]]</code></a>
      of objects are compared using
      the <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality"><code>===</code>
        operator</a>.</li>
    <li>Only <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">enumerable
        &quot;own&quot; properties</a> are considered.</li>
    <li><a href="errors.md#class-error"><code>Error</code></a> names and messages are always compared, even if these are
      not
      enumerable properties.</li>
    <li>Enumerable own <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>
      properties are compared as well.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive#Primitive_wrapper_objects_in_JavaScript">Object
        wrappers</a> are compared both as objects and unwrapped values.</li>
    <li><code>Object</code> properties are compared unordered.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>
      keys and <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>
      items are compared unordered.</li>
    <li>Recursion stops when both sides differ or both sides encounter a circular
      reference.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><code>WeakMap</code></a>
      and <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a>
      comparison does not rely on their values. See
      below for further details.</li>
    <li><a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>
      lastIndex, flags and source are always compared, even if these
      are not enumerable properties.</li>
  </ul>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-comment">// This fails because 1 !== &#x27;1&#x27;.</span>
assert.deepStrictEqual({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, { <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span> });
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   {</span>
<span class="hljs-comment">// +   a: 1</span>
<span class="hljs-comment">// -   a: &#x27;1&#x27;</span>
<span class="hljs-comment">//   }</span>

<span class="hljs-comment">// The following objects don&#x27;t have own properties</span>
<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
<span class="hljs-keyword">const</span> object = {};
<span class="hljs-keyword">const</span> fakeDate = {};
<span class="hljs-built_in">Object</span>.setPrototypeOf(fakeDate, <span class="hljs-built_in">Date</span>.prototype);

<span class="hljs-comment">// Different [[Prototype]]:</span>
assert.deepStrictEqual(object, fakeDate);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + {}</span>
<span class="hljs-comment">// - Date {}</span>

<span class="hljs-comment">// Different type tags:</span>
assert.deepStrictEqual(date, fakeDate);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + 2018-04-26T00:49:08.604Z</span>
<span class="hljs-comment">// - Date {}</span>

assert.deepStrictEqual(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>);
<span class="hljs-comment">// OK because Object.is(NaN, NaN) is true.</span>

<span class="hljs-comment">// Different unwrapped numbers:</span>
assert.deepStrictEqual(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>));
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + [Number: 1]</span>
<span class="hljs-comment">// - [Number: 2]</span>

assert.deepStrictEqual(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;foo&#x27;</span>), <span class="hljs-built_in">Object</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));
<span class="hljs-comment">// OK because the object and the string are identical when unwrapped.</span>

assert.deepStrictEqual(<span class="hljs-number">-0</span>, <span class="hljs-number">-0</span>);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Different zeros:</span>
assert.deepStrictEqual(<span class="hljs-number">0</span>, <span class="hljs-number">-0</span>);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + 0</span>
<span class="hljs-comment">// - -0</span>

<span class="hljs-keyword">const</span> symbol1 = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> symbol2 = <span class="hljs-built_in">Symbol</span>();
assert.deepStrictEqual({ [symbol1]: <span class="hljs-number">1</span> }, { [symbol1]: <span class="hljs-number">1</span> });
<span class="hljs-comment">// OK, because it is the same symbol on both objects.</span>

assert.deepStrictEqual({ [symbol1]: <span class="hljs-number">1</span> }, { [symbol2]: <span class="hljs-number">1</span> });
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   [Symbol()]: 1</span>
<span class="hljs-comment">// }</span>

<span class="hljs-keyword">const</span> weakMap1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
<span class="hljs-keyword">const</span> weakMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>([[{}, {}]]);
<span class="hljs-keyword">const</span> weakMap3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
weakMap3.unequal = <span class="hljs-literal">true</span>;

assert.deepStrictEqual(weakMap1, weakMap2);
<span class="hljs-comment">// OK, because it is impossible to compare the entries</span>

<span class="hljs-comment">// Fails because weakMap3 has a property that weakMap1 does not contain:</span>
assert.deepStrictEqual(weakMap1, weakMap3);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   WeakMap {</span>
<span class="hljs-comment">// +   [items unknown]</span>
<span class="hljs-comment">// -   [items unknown],</span>
<span class="hljs-comment">// -   unequal: true</span>
<span class="hljs-comment">//   }</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

<span class="hljs-comment">// This fails because 1 !== &#x27;1&#x27;.</span>
assert.deepStrictEqual({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, { <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span> });
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   {</span>
<span class="hljs-comment">// +   a: 1</span>
<span class="hljs-comment">// -   a: &#x27;1&#x27;</span>
<span class="hljs-comment">//   }</span>

<span class="hljs-comment">// The following objects don&#x27;t have own properties</span>
<span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
<span class="hljs-keyword">const</span> object = {};
<span class="hljs-keyword">const</span> fakeDate = {};
<span class="hljs-built_in">Object</span>.setPrototypeOf(fakeDate, <span class="hljs-built_in">Date</span>.prototype);

<span class="hljs-comment">// Different [[Prototype]]:</span>
assert.deepStrictEqual(object, fakeDate);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + {}</span>
<span class="hljs-comment">// - Date {}</span>

<span class="hljs-comment">// Different type tags:</span>
assert.deepStrictEqual(date, fakeDate);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + 2018-04-26T00:49:08.604Z</span>
<span class="hljs-comment">// - Date {}</span>

assert.deepStrictEqual(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>);
<span class="hljs-comment">// OK because Object.is(NaN, NaN) is true.</span>

<span class="hljs-comment">// Different unwrapped numbers:</span>
assert.deepStrictEqual(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>));
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + [Number: 1]</span>
<span class="hljs-comment">// - [Number: 2]</span>

assert.deepStrictEqual(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;foo&#x27;</span>), <span class="hljs-built_in">Object</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));
<span class="hljs-comment">// OK because the object and the string are identical when unwrapped.</span>

assert.deepStrictEqual(<span class="hljs-number">-0</span>, <span class="hljs-number">-0</span>);
<span class="hljs-comment">// OK</span>

<span class="hljs-comment">// Different zeros:</span>
assert.deepStrictEqual(<span class="hljs-number">0</span>, <span class="hljs-number">-0</span>);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + 0</span>
<span class="hljs-comment">// - -0</span>

<span class="hljs-keyword">const</span> symbol1 = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> symbol2 = <span class="hljs-built_in">Symbol</span>();
assert.deepStrictEqual({ [symbol1]: <span class="hljs-number">1</span> }, { [symbol1]: <span class="hljs-number">1</span> });
<span class="hljs-comment">// OK, because it is the same symbol on both objects.</span>

assert.deepStrictEqual({ [symbol1]: <span class="hljs-number">1</span> }, { [symbol2]: <span class="hljs-number">1</span> });
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   [Symbol()]: 1</span>
<span class="hljs-comment">// }</span>

<span class="hljs-keyword">const</span> weakMap1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
<span class="hljs-keyword">const</span> weakMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>([[{}, {}]]);
<span class="hljs-keyword">const</span> weakMap3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
weakMap3.unequal = <span class="hljs-literal">true</span>;

assert.deepStrictEqual(weakMap1, weakMap2);
<span class="hljs-comment">// OK, because it is impossible to compare the entries</span>

<span class="hljs-comment">// Fails because weakMap3 has a property that weakMap1 does not contain:</span>
assert.deepStrictEqual(weakMap1, weakMap3);
<span class="hljs-comment">// AssertionError: Expected inputs to be strictly deep-equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   WeakMap {</span>
<span class="hljs-comment">// +   [items unknown]</span>
<span class="hljs-comment">// -   [items unknown],</span>
<span class="hljs-comment">// -   unequal: true</span>
<span class="hljs-comment">//   }</span>
</div></code></pre>
  <p>If the values are not equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown
    with a <code>message</code>
    property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
    parameter is undefined, a default error message is assigned. If the <code>message</code>
    parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead
    of the
    <code>AssertionError</code>.</p>
  <h2 id="assertdoesnotmatchstring-regexp-message"><code>assert.doesNotMatch(string, regexp[, message])</code></h2>
  <!-- YAML
added:
  - v13.6.0
  - v12.16.0
changes:
  - version: v16.0.0
    pr-url: https://github.com/nodejs/node/pull/38111
    description: This API is no longer experimental.
-->
  <ul>
    <li><code>string</code> {string}</li>
    <li><code>regexp</code> {RegExp}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Expects the <code>string</code> input not to match the regular expression.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.doesNotMatch(<span class="hljs-string">&#x27;I will fail&#x27;</span>, <span class="hljs-regexp">/fail/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The input was expected to not match the ...</span>

assert.doesNotMatch(<span class="hljs-number">123</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The &quot;string&quot; argument must be of type string.</span>

assert.doesNotMatch(<span class="hljs-string">&#x27;I will pass&#x27;</span>, <span class="hljs-regexp">/different/</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.doesNotMatch(<span class="hljs-string">&#x27;I will fail&#x27;</span>, <span class="hljs-regexp">/fail/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The input was expected to not match the ...</span>

assert.doesNotMatch(<span class="hljs-number">123</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The &quot;string&quot; argument must be of type string.</span>

assert.doesNotMatch(<span class="hljs-string">&#x27;I will pass&#x27;</span>, <span class="hljs-regexp">/different/</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <p>If the values do match, or if the <code>string</code> argument is of another type than
    <code>string</code>, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown with a
    <code>message</code> property set equal
    to the value of the <code>message</code> parameter. If the <code>message</code> parameter is
    undefined, a default error message is assigned. If the <code>message</code> parameter is an
    instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead of the
    <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <h2 id="assertdoesnotrejectasyncfn-error"><code>assert.doesNotReject(asyncFn[, error][, message])</code></h2>
  <!-- YAML
added: v10.0.0
-->
  <ul>
    <li><code>asyncFn</code> {Function|Promise}</li>
    <li><code>error</code> {RegExp|Function}</li>
    <li><code>message</code> {string}</li>
  </ul>
  <p>Awaits the <code>asyncFn</code> promise or, if <code>asyncFn</code> is a function, immediately
    calls the function and awaits the returned promise to complete. It will then
    check that the promise is not rejected.</p>
  <p>If <code>asyncFn</code> is a function and it throws an error synchronously,
    <code>assert.doesNotReject()</code> will return a rejected <code>Promise</code> with that error. If
    the function does not return a promise, <code>assert.doesNotReject()</code> will return a
    rejected <code>Promise</code> with an <a
      href="errors.md#err_invalid_return_value"><code>ERR_INVALID_RETURN_VALUE</code></a> error. In both cases
    the error handler is skipped.</p>
  <p>Using <code>assert.doesNotReject()</code> is actually not useful because there is little
    benefit in catching a rejection and then rejecting it again. Instead, consider
    adding a comment next to the specific code path that should not reject and keep
    error messages as expressive as possible.</p>
  <p>If specified, <code>error</code> can be a <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>
    or a validation
    function. See <a href="#assertthrowsfn-error-message"><code>assert.throws()</code></a> for more details.</p>
  <p>Besides the async nature to await the completion behaves identically to
    <a href="#assertdoesnotthrowfn-error-message"><code>assert.doesNotThrow()</code></a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-keyword">await</span> assert.doesNotReject(
  <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">SyntaxError</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> assert.doesNotReject(
    <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
    },
    <span class="hljs-built_in">SyntaxError</span>
  );
})();
</div></code></pre>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.doesNotReject(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>)))
  .then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// ...</span>
  });
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.doesNotReject(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>)))
  .then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// ...</span>
  });
</div></code></pre>
  <h2 id="assertdoesnotthrowfn-error"><code>assert.doesNotThrow(fn[, error][, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version:
    - v5.11.0
    - v4.4.5
    pr-url: https://github.com/nodejs/node/pull/2407
    description: The `message` parameter is respected now.
  - version: v4.2.0
    pr-url: https://github.com/nodejs/node/pull/3276
    description: The `error` parameter can now be an arrow function.
-->
  <ul>
    <li><code>fn</code> {Function}</li>
    <li><code>error</code> {RegExp|Function}</li>
    <li><code>message</code> {string}</li>
  </ul>
  <p>Asserts that the function <code>fn</code> does not throw an error.</p>
  <p>Using <code>assert.doesNotThrow()</code> is actually not useful because there
    is no benefit in catching an error and then rethrowing it. Instead, consider
    adding a comment next to the specific code path that should not throw and keep
    error messages as expressive as possible.</p>
  <p>When <code>assert.doesNotThrow()</code> is called, it will immediately call the <code>fn</code>
    function.</p>
  <p>If an error is thrown and it is the same type as that specified by the <code>error</code>
    parameter, then an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown. If the error is
    of a
    different type, or if the <code>error</code> parameter is undefined, the error is
    propagated back to the caller.</p>
  <p>If specified, <code>error</code> can be a <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>
    or a validation
    function. See <a href="#assertthrowsfn-error-message"><code>assert.throws()</code></a> for more details.</p>
  <p>The following, for instance, will throw the <a href="errors.md#class-typeerror"><code>TypeError</code></a> because
    there is no
    matching error type in the assertion:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">SyntaxError</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">SyntaxError</span>
);
</div></code></pre>
  <p>However, the following will result in an <a href="#class-assertassertionerror"><code>AssertionError</code></a> with
    the message
    'Got unwanted exception...':</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">TypeError</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">TypeError</span>
);
</div></code></pre>
  <p>If an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown and a value is provided for
    the <code>message</code>
    parameter, the value of <code>message</code> will be appended to the <a
      href="#class-assertassertionerror"><code>AssertionError</code></a>
    message:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-regexp">/Wrong value/</span>,
  <span class="hljs-string">&#x27;Whoops&#x27;</span>
);
<span class="hljs-comment">// Throws: AssertionError: Got unwanted exception: Whoops</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.doesNotThrow(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-regexp">/Wrong value/</span>,
  <span class="hljs-string">&#x27;Whoops&#x27;</span>
);
<span class="hljs-comment">// Throws: AssertionError: Got unwanted exception: Whoops</span>
</div></code></pre>
  <h2 id="assertequalactual-expected-message"><code>assert.equal(actual, expected[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version:
      - v16.0.0
      - v14.18.0
    pr-url: https://github.com/nodejs/node/pull/38113
    description: In Legacy assertion mode, changed status from Deprecated to
                 Legacy.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30766
    description: NaN is now treated as being identical if both sides are
                 NaN.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p><strong>Strict assertion mode</strong></p>
  <p>An alias of <a href="#assertstrictequalactual-expected-message"><code>assert.strictEqual()</code></a>.</p>
  <p><strong>Legacy assertion mode</strong></p>
  <blockquote>
    <p>Stability: 3 - Legacy: Use <a
        href="#assertstrictequalactual-expected-message"><code>assert.strictEqual()</code></a> instead.</p>
  </blockquote>
  <p>Tests shallow, coercive equality between the <code>actual</code> and <code>expected</code> parameters
    using the <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code>
      operator</a>. <code>NaN</code> is specially handled
    and treated as being identical if both sides are <code>NaN</code>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

assert.equal(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// OK, 1 == 1</span>
assert.equal(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// OK, 1 == &#x27;1&#x27;</span>
assert.equal(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>);
<span class="hljs-comment">// OK</span>

assert.equal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// AssertionError: 1 == 2</span>
assert.equal({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } }, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } });
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } == { a: { b: 1 } }</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

assert.equal(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// OK, 1 == 1</span>
assert.equal(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// OK, 1 == &#x27;1&#x27;</span>
assert.equal(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>);
<span class="hljs-comment">// OK</span>

assert.equal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// AssertionError: 1 == 2</span>
assert.equal({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } }, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } });
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } == { a: { b: 1 } }</span>
</div></code></pre>
  <p>If the values are not equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown
    with a <code>message</code>
    property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
    parameter is undefined, a default error message is assigned. If the <code>message</code>
    parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead
    of the
    <code>AssertionError</code>.</p>
  <h2 id="assertfailmessage"><code>assert.fail([message])</code></h2>
  <!-- YAML
added: v0.1.21
-->
  <ul>
    <li><code>message</code> {string|Error} <strong>Default:</strong> <code>'Failed'</code></li>
  </ul>
  <p>Throws an <a href="#class-assertassertionerror"><code>AssertionError</code></a> with the provided error message or
    a default
    error message. If the <code>message</code> parameter is an instance of an <a
      href="errors.md#class-error"><code>Error</code></a> then
    it will be thrown instead of the <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.fail();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Failed</span>

assert.fail(<span class="hljs-string">&#x27;boom&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: boom</span>

assert.fail(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;need array&#x27;</span>));
<span class="hljs-comment">// TypeError: need array</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.fail();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Failed</span>

assert.fail(<span class="hljs-string">&#x27;boom&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: boom</span>

assert.fail(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;need array&#x27;</span>));
<span class="hljs-comment">// TypeError: need array</span>
</div></code></pre>
  <p>Using <code>assert.fail()</code> with more than two arguments is possible but deprecated.
    See below for further details.</p>
  <h2 id="assertfailactual-expected-message-operator-stackstartfn"><code>assert.fail(actual, expected[, message[,
      operator[, stackStartFn]]])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18418
    description: Calling `assert.fail()` with more than one argument is
                 deprecated and emits a warning.
-->
  <blockquote>
    <p>Stability: 0 - Deprecated: Use <code>assert.fail([message])</code> or other assert
      functions instead.</p>
  </blockquote>
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
    <li><code>operator</code> {string} <strong>Default:</strong> <code>'!='</code></li>
    <li><code>stackStartFn</code> {Function} <strong>Default:</strong> <code>assert.fail</code></li>
  </ul>
  <p>If <code>message</code> is falsy, the error message is set as the values of <code>actual</code> and
    <code>expected</code> separated by the provided <code>operator</code>. If just the two <code>actual</code> and
    <code>expected</code> arguments are provided, <code>operator</code> will default to <code>'!='</code>. If
    <code>message</code> is provided as third argument it will be used as the error message and
    the other arguments will be stored as properties on the thrown object. If
    <code>stackStartFn</code> is provided, all stack frames above that function will be
    removed from stacktrace (see <a
      href="errors.md#errorcapturestacktracetargetobject-constructoropt"><code>Error.captureStackTrace</code></a>). If
    no arguments are
    given, the default message <code>Failed</code> will be used.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.fail(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: &#x27;a&#x27; != &#x27;b&#x27;</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: 1 &gt; 2</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;fail&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: fail</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;whoops&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: whoops</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;need array&#x27;</span>));
<span class="hljs-comment">// TypeError: need array</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.fail(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: &#x27;a&#x27; != &#x27;b&#x27;</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: 1 &gt; 2</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;fail&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: fail</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;whoops&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: whoops</span>

assert.fail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;need array&#x27;</span>));
<span class="hljs-comment">// TypeError: need array</span>
</div></code></pre>
  <p>In the last three cases <code>actual</code>, <code>expected</code>, and <code>operator</code> have no
    influence on the error message.</p>
  <p>Example use of <code>stackStartFn</code> for truncating the exception's stacktrace:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">suppressFrame</span>(<span class="hljs-params"></span>) </span>{
  assert.fail(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;!==&#x27;</span>, suppressFrame);
}
suppressFrame();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: &#x27;a&#x27; !== &#x27;b&#x27;</span>
<span class="hljs-comment">//     at repl:1:1</span>
<span class="hljs-comment">//     at ContextifyScript.Script.runInThisContext (vm.js:44:33)</span>
<span class="hljs-comment">//     ...</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">suppressFrame</span>(<span class="hljs-params"></span>) </span>{
  assert.fail(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;!==&#x27;</span>, suppressFrame);
}
suppressFrame();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: &#x27;a&#x27; !== &#x27;b&#x27;</span>
<span class="hljs-comment">//     at repl:1:1</span>
<span class="hljs-comment">//     at ContextifyScript.Script.runInThisContext (vm.js:44:33)</span>
<span class="hljs-comment">//     ...</span>
</div></code></pre>
  <h2 id="assertiferrorvalue"><code>assert.ifError(value)</code></h2>
  <!-- YAML
added: v0.1.97
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18247
    description: Instead of throwing the original error it is now wrapped into
                 an [`AssertionError`][] that contains the full stack trace.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18247
    description: Value may now only be `undefined` or `null`. Before all falsy
                 values were handled the same as `null` and did not throw.
-->
  <ul>
    <li><code>value</code> {any}</li>
  </ul>
  <p>Throws <code>value</code> if <code>value</code> is not <code>undefined</code> or <code>null</code>. This is useful
    when
    testing the <code>error</code> argument in callbacks. The stack trace contains all frames
    from the error passed to <code>ifError()</code> including the potential new frames for
    <code>ifError()</code> itself.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.ifError(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// OK</span>
assert.ifError(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0</span>
assert.ifError(<span class="hljs-string">&#x27;error&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: &#x27;error&#x27;</span>
assert.ifError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error</span>

<span class="hljs-comment">// Create some random error frames.</span>
<span class="hljs-keyword">let</span> err;
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorFrame</span>(<span class="hljs-params"></span>) </span>{
  err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test error&#x27;</span>);
})();

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ifErrorFrame</span>(<span class="hljs-params"></span>) </span>{
  assert.ifError(err);
})();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error</span>
<span class="hljs-comment">//     at ifErrorFrame</span>
<span class="hljs-comment">//     at errorFrame</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.ifError(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// OK</span>
assert.ifError(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0</span>
assert.ifError(<span class="hljs-string">&#x27;error&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: &#x27;error&#x27;</span>
assert.ifError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error</span>

<span class="hljs-comment">// Create some random error frames.</span>
<span class="hljs-keyword">let</span> err;
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorFrame</span>(<span class="hljs-params"></span>) </span>{
  err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test error&#x27;</span>);
})();

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ifErrorFrame</span>(<span class="hljs-params"></span>) </span>{
  assert.ifError(err);
})();
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error</span>
<span class="hljs-comment">//     at ifErrorFrame</span>
<span class="hljs-comment">//     at errorFrame</span>
</div></code></pre>
  <h2 id="assertmatchstring-regexp-message"><code>assert.match(string, regexp[, message])</code></h2>
  <!-- YAML
added:
  - v13.6.0
  - v12.16.0
changes:
  - version: v16.0.0
    pr-url: https://github.com/nodejs/node/pull/38111
    description: This API is no longer experimental.
-->
  <ul>
    <li><code>string</code> {string}</li>
    <li><code>regexp</code> {RegExp}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Expects the <code>string</code> input to match the regular expression.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.match(<span class="hljs-string">&#x27;I will fail&#x27;</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The input did not match the regular ...</span>

assert.match(<span class="hljs-number">123</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The &quot;string&quot; argument must be of type string.</span>

assert.match(<span class="hljs-string">&#x27;I will pass&#x27;</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.match(<span class="hljs-string">&#x27;I will fail&#x27;</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The input did not match the regular ...</span>

assert.match(<span class="hljs-number">123</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: The &quot;string&quot; argument must be of type string.</span>

assert.match(<span class="hljs-string">&#x27;I will pass&#x27;</span>, <span class="hljs-regexp">/pass/</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <p>If the values do not match, or if the <code>string</code> argument is of another type than
    <code>string</code>, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown with a
    <code>message</code> property set equal
    to the value of the <code>message</code> parameter. If the <code>message</code> parameter is
    undefined, a default error message is assigned. If the <code>message</code> parameter is an
    instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead of the
    <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <h2 id="assertnotdeepequalactual-expected-message"><code>assert.notDeepEqual(actual, expected[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version:
      - v16.0.0
      - v14.18.0
    pr-url: https://github.com/nodejs/node/pull/38113
    description: In Legacy assertion mode, changed status from Deprecated to
                 Legacy.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30766
    description: NaN is now treated as being identical if both sides are
                 NaN.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15001
    description: The `Error` names and messages are now properly compared.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12142
    description: The `Set` and `Map` content is also compared.
  - version:
      - v6.4.0
      - v4.7.1
    pr-url: https://github.com/nodejs/node/pull/8002
    description: Typed array slices are handled correctly now.
  - version:
      - v6.1.0
      - v4.5.0
    pr-url: https://github.com/nodejs/node/pull/6432
    description: Objects with circular references can be used as inputs now.
  - version:
      - v5.10.1
      - v4.4.3
    pr-url: https://github.com/nodejs/node/pull/5910
    description: Handle non-`Uint8Array` typed arrays correctly.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p><strong>Strict assertion mode</strong></p>
  <p>An alias of <a
      href="#assertnotdeepstrictequalactual-expected-message"><code>assert.notDeepStrictEqual()</code></a>.</p>
  <p><strong>Legacy assertion mode</strong></p>
  <blockquote>
    <p>Stability: 3 - Legacy: Use <a
        href="#assertnotdeepstrictequalactual-expected-message"><code>assert.notDeepStrictEqual()</code></a> instead.
    </p>
  </blockquote>
  <p>Tests for any deep inequality. Opposite of <a
      href="#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

<span class="hljs-keyword">const</span> obj1 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>
  }
};
<span class="hljs-keyword">const</span> obj3 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj4 = <span class="hljs-built_in">Object</span>.create(obj1);

assert.notDeepEqual(obj1, obj1);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }</span>

assert.notDeepEqual(obj1, obj2);
<span class="hljs-comment">// OK</span>

assert.notDeepEqual(obj1, obj3);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }</span>

assert.notDeepEqual(obj1, obj4);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-keyword">const</span> obj1 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>
  }
};
<span class="hljs-keyword">const</span> obj3 = {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>
  }
};
<span class="hljs-keyword">const</span> obj4 = <span class="hljs-built_in">Object</span>.create(obj1);

assert.notDeepEqual(obj1, obj1);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }</span>

assert.notDeepEqual(obj1, obj2);
<span class="hljs-comment">// OK</span>

assert.notDeepEqual(obj1, obj3);
<span class="hljs-comment">// AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }</span>

assert.notDeepEqual(obj1, obj4);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <p>If the values are deeply equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown
    with a
    <code>message</code> property set equal to the value of the <code>message</code> parameter. If the
    <code>message</code> parameter is undefined, a default error message is assigned. If the
    <code>message</code> parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it
    will be thrown
    instead of the <code>AssertionError</code>.</p>
  <h2 id="assertnotdeepstrictequalactual-expected-message"><code>assert.notDeepStrictEqual(actual, expected[,
      message])</code></h2>
  <!-- YAML
added: v1.2.0
changes:
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15398
    description: The `-0` and `+0` are not considered equal anymore.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15036
    description: The `NaN` is now compared using the
              [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero)
              comparison.
  - version: v9.0.0
    pr-url: https://github.com/nodejs/node/pull/15001
    description: The `Error` names and messages are now properly compared.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12142
    description: The `Set` and `Map` content is also compared.
  - version:
    - v6.4.0
    - v4.7.1
    pr-url: https://github.com/nodejs/node/pull/8002
    description: Typed array slices are handled correctly now.
  - version: v6.1.0
    pr-url: https://github.com/nodejs/node/pull/6432
    description: Objects with circular references can be used as inputs now.
  - version:
    - v5.10.1
    - v4.4.3
    pr-url: https://github.com/nodejs/node/pull/5910
    description: Handle non-`Uint8Array` typed arrays correctly.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Tests for deep strict inequality. Opposite of <a
      href="#assertdeepstrictequalactual-expected-message"><code>assert.deepStrictEqual()</code></a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.notDeepStrictEqual({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, { <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span> });
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.notDeepStrictEqual({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, { <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span> });
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <p>If the values are deeply and strictly equal, an <a
      href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown
    with a <code>message</code> property set equal to the value of the <code>message</code> parameter. If
    the <code>message</code> parameter is undefined, a default error message is assigned. If
    the <code>message</code> parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then
    it will be thrown
    instead of the <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <h2 id="assertnotequalactual-expected-message"><code>assert.notEqual(actual, expected[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version:
      - v16.0.0
      - v14.18.0
    pr-url: https://github.com/nodejs/node/pull/38113
    description: In Legacy assertion mode, changed status from Deprecated to
                 Legacy.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30766
    description: NaN is now treated as being identical if both sides are
                 NaN.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p><strong>Strict assertion mode</strong></p>
  <p>An alias of <a href="#assertnotstrictequalactual-expected-message"><code>assert.notStrictEqual()</code></a>.</p>
  <p><strong>Legacy assertion mode</strong></p>
  <blockquote>
    <p>Stability: 3 - Legacy: Use <a
        href="#assertnotstrictequalactual-expected-message"><code>assert.notStrictEqual()</code></a> instead.</p>
  </blockquote>
  <p>Tests shallow, coercive inequality with the <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality"><code>!=</code>
      operator</a>. <code>NaN</code> is
    specially handled and treated as being identical if both sides are <code>NaN</code>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert&#x27;</span>;

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// OK</span>

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// AssertionError: 1 != 1</span>

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// AssertionError: 1 != &#x27;1&#x27;</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// OK</span>

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// AssertionError: 1 != 1</span>

assert.notEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// AssertionError: 1 != &#x27;1&#x27;</span>
</div></code></pre>
  <p>If the values are equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is thrown with a
    <code>message</code>
    property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
    parameter is undefined, a default error message is assigned. If the <code>message</code>
    parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead
    of the
    <code>AssertionError</code>.</p>
  <h2 id="assertnotstrictequalactual-expected-message"><code>assert.notStrictEqual(actual, expected[, message])</code>
  </h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/17003
    description: Used comparison changed from Strict Equality to `Object.is()`.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Tests strict inequality between the <code>actual</code> and <code>expected</code> parameters as
    determined by <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a>.
  </p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// OK</span>

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected &quot;actual&quot; to be strictly unequal to:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1</span>

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// OK</span>

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected &quot;actual&quot; to be strictly unequal to:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1</span>

assert.notStrictEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// OK</span>
</div></code></pre>
  <p>If the values are strictly equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is
    thrown with a
    <code>message</code> property set equal to the value of the <code>message</code> parameter. If the
    <code>message</code> parameter is undefined, a default error message is assigned. If the
    <code>message</code> parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it
    will be thrown
    instead of the <code>AssertionError</code>.</p>
  <h2 id="assertokvalue-message"><code>assert.ok(value[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18319
    description: The `assert.ok()` (no arguments) will now use a predefined
                 error message.
-->
  <ul>
    <li><code>value</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Tests if <code>value</code> is truthy. It is equivalent to
    <code>assert.equal(!!value, true, message)</code>.</p>
  <p>If <code>value</code> is not truthy, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is
    thrown with a <code>message</code>
    property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
    parameter is <code>undefined</code>, a default error message is assigned. If the <code>message</code>
    parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it will be thrown instead
    of the
    <code>AssertionError</code>.
    If no arguments are passed in at all <code>message</code> will be set to the string:
    <code>'No value argument passed to `assert.ok()`'</code>.</p>
  <p>Be aware that in the <code>repl</code> the error message will be different to the one
    thrown in a file! See below for further details.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.ok(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// OK</span>
assert.ok(<span class="hljs-number">1</span>);
<span class="hljs-comment">// OK</span>

assert.ok();
<span class="hljs-comment">// AssertionError: No value argument passed to `assert.ok()`</span>

assert.ok(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;it\&#x27;s false&#x27;</span>);
<span class="hljs-comment">// AssertionError: it&#x27;s false</span>

<span class="hljs-comment">// In the repl:</span>
assert.ok(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> === <span class="hljs-string">&#x27;string&#x27;</span>);
<span class="hljs-comment">// AssertionError: false == true</span>

<span class="hljs-comment">// In a file (e.g. test.js):</span>
assert.ok(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> === <span class="hljs-string">&#x27;string&#x27;</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(typeof 123 === &#x27;string&#x27;)</span>

assert.ok(<span class="hljs-literal">false</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(false)</span>

assert.ok(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(0)</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.ok(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// OK</span>
assert.ok(<span class="hljs-number">1</span>);
<span class="hljs-comment">// OK</span>

assert.ok();
<span class="hljs-comment">// AssertionError: No value argument passed to `assert.ok()`</span>

assert.ok(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;it\&#x27;s false&#x27;</span>);
<span class="hljs-comment">// AssertionError: it&#x27;s false</span>

<span class="hljs-comment">// In the repl:</span>
assert.ok(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> === <span class="hljs-string">&#x27;string&#x27;</span>);
<span class="hljs-comment">// AssertionError: false == true</span>

<span class="hljs-comment">// In a file (e.g. test.js):</span>
assert.ok(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> === <span class="hljs-string">&#x27;string&#x27;</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(typeof 123 === &#x27;string&#x27;)</span>

assert.ok(<span class="hljs-literal">false</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(false)</span>

assert.ok(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert.ok(0)</span>
</div></code></pre>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-comment">// Using `assert()` works the same:</span>
assert(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert(0)</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);

<span class="hljs-comment">// Using `assert()` works the same:</span>
assert(<span class="hljs-number">0</span>);
<span class="hljs-comment">// AssertionError: The expression evaluated to a falsy value:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//   assert(0)</span>
</div></code></pre>
  <h2 id="assertrejectsasyncfn-error"><code>assert.rejects(asyncFn[, error][, message])</code></h2>
  <!-- YAML
added: v10.0.0
-->
  <ul>
    <li><code>asyncFn</code> {Function|Promise}</li>
    <li><code>error</code> {RegExp|Function|Object|Error}</li>
    <li><code>message</code> {string}</li>
  </ul>
  <p>Awaits the <code>asyncFn</code> promise or, if <code>asyncFn</code> is a function, immediately
    calls the function and awaits the returned promise to complete. It will then
    check that the promise is rejected.</p>
  <p>If <code>asyncFn</code> is a function and it throws an error synchronously,
    <code>assert.rejects()</code> will return a rejected <code>Promise</code> with that error. If the
    function does not return a promise, <code>assert.rejects()</code> will return a rejected
    <code>Promise</code> with an <a href="errors.md#err_invalid_return_value"><code>ERR_INVALID_RETURN_VALUE</code></a>
    error. In both cases the error
    handler is skipped.</p>
  <p>Besides the async nature to await the completion behaves identically to
    <a href="#assertthrowsfn-error-message"><code>assert.throws()</code></a>.</p>
  <p>If specified, <code>error</code> can be a <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>,
    a validation function,
    an object where each property will be tested for, or an instance of error where
    each property will be tested for including the non-enumerable <code>message</code> and
    <code>name</code> properties.</p>
  <p>If specified, <code>message</code> will be the message provided by the <a
      href="#class-assertassertionerror"><code>AssertionError</code></a>
    if the <code>asyncFn</code> fails to reject.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-keyword">await</span> assert.rejects(
  <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TypeError&#x27;</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Wrong value&#x27;</span>
  }
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> assert.rejects(
    <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
    },
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TypeError&#x27;</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Wrong value&#x27;</span>
    }
  );
})();
</div></code></pre>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-keyword">await</span> assert.rejects(
  <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    assert.strictEqual(err.name, <span class="hljs-string">&#x27;TypeError&#x27;</span>);
    assert.strictEqual(err.message, <span class="hljs-string">&#x27;Wrong value&#x27;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> assert.rejects(
    <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
    },
    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      assert.strictEqual(err.name, <span class="hljs-string">&#x27;TypeError&#x27;</span>);
      assert.strictEqual(err.message, <span class="hljs-string">&#x27;Wrong value&#x27;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  );
})();
</div></code></pre>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.rejects(
  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>)),
  <span class="hljs-built_in">Error</span>
).then(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.rejects(
  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>)),
  <span class="hljs-built_in">Error</span>
).then(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});
</div></code></pre>
  <p><code>error</code> cannot be a string. If a string is provided as the second
    argument, then <code>error</code> is assumed to be omitted and the string will be used for
    <code>message</code> instead. This can lead to easy-to-miss mistakes. Please read the
    example in <a href="#assertthrowsfn-error-message"><code>assert.throws()</code></a> carefully if using a string as
    the second
    argument gets considered.</p>
  <h2 id="assertstrictequalactual-expected-message"><code>assert.strictEqual(actual, expected[, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/17003
    description: Used comparison changed from Strict Equality to `Object.is()`.
-->
  <ul>
    <li><code>actual</code> {any}</li>
    <li><code>expected</code> {any}</li>
    <li><code>message</code> {string|Error}</li>
  </ul>
  <p>Tests strict equality between the <code>actual</code> and <code>expected</code> parameters as
    determined by <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a>.
  </p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1 !== 2</span>

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// OK</span>

assert.strictEqual(<span class="hljs-string">&#x27;Hello foobar&#x27;</span>, <span class="hljs-string">&#x27;Hello World!&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + &#x27;Hello foobar&#x27;</span>
<span class="hljs-comment">// - &#x27;Hello World!&#x27;</span>
<span class="hljs-comment">//          ^</span>

<span class="hljs-keyword">const</span> apples = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> oranges = <span class="hljs-number">2</span>;
assert.strictEqual(apples, oranges, <span class="hljs-string">`apples <span class="hljs-subst">${apples}</span> !== oranges <span class="hljs-subst">${oranges}</span>`</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2</span>

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Inputs are not identical&#x27;</span>));
<span class="hljs-comment">// TypeError: Inputs are not identical</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1 !== 2</span>

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// OK</span>

assert.strictEqual(<span class="hljs-string">&#x27;Hello foobar&#x27;</span>, <span class="hljs-string">&#x27;Hello World!&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:</span>
<span class="hljs-comment">// + actual - expected</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// + &#x27;Hello foobar&#x27;</span>
<span class="hljs-comment">// - &#x27;Hello World!&#x27;</span>
<span class="hljs-comment">//          ^</span>

<span class="hljs-keyword">const</span> apples = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> oranges = <span class="hljs-number">2</span>;
assert.strictEqual(apples, oranges, <span class="hljs-string">`apples <span class="hljs-subst">${apples}</span> !== oranges <span class="hljs-subst">${oranges}</span>`</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2</span>

assert.strictEqual(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Inputs are not identical&#x27;</span>));
<span class="hljs-comment">// TypeError: Inputs are not identical</span>
</div></code></pre>
  <p>If the values are not strictly equal, an <a href="#class-assertassertionerror"><code>AssertionError</code></a> is
    thrown with a
    <code>message</code> property set equal to the value of the <code>message</code> parameter. If the
    <code>message</code> parameter is undefined, a default error message is assigned. If the
    <code>message</code> parameter is an instance of an <a href="errors.md#class-error"><code>Error</code></a> then it
    will be thrown
    instead of the <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <h2 id="assertthrowsfn-error"><code>assert.throws(fn[, error][, message])</code></h2>
  <!-- YAML
added: v0.1.21
changes:
  - version: v10.2.0
    pr-url: https://github.com/nodejs/node/pull/20485
    description: The `error` parameter can be an object containing regular
                 expressions now.
  - version: v9.9.0
    pr-url: https://github.com/nodejs/node/pull/17584
    description: The `error` parameter can now be an object as well.
  - version: v4.2.0
    pr-url: https://github.com/nodejs/node/pull/3276
    description: The `error` parameter can now be an arrow function.
-->
  <ul>
    <li><code>fn</code> {Function}</li>
    <li><code>error</code> {RegExp|Function|Object|Error}</li>
    <li><code>message</code> {string}</li>
  </ul>
  <p>Expects the function <code>fn</code> to throw an error.</p>
  <p>If specified, <code>error</code> can be a <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>,
    a validation function,
    a validation object where each property will be tested for strict deep equality,
    or an instance of error where each property will be tested for strict deep
    equality including the non-enumerable <code>message</code> and <code>name</code> properties. When
    using an object, it is also possible to use a regular expression, when
    validating against a string property. See below for examples.</p>
  <p>If specified, <code>message</code> will be appended to the message provided by the
    <code>AssertionError</code> if the <code>fn</code> call fails to throw or in case the error validation
    fails.</p>
  <p>Custom validation object/error instance:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
err.code = <span class="hljs-number">404</span>;
err.foo = <span class="hljs-string">&#x27;bar&#x27;</span>;
err.info = {
  <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
};
err.reg = <span class="hljs-regexp">/abc/i</span>;

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> err;
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TypeError&#x27;</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Wrong value&#x27;</span>,
    <span class="hljs-attr">info</span>: {
      <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
    }
    <span class="hljs-comment">// Only properties on the validation object will be tested for.</span>
    <span class="hljs-comment">// Using nested objects requires all properties to be present. Otherwise</span>
    <span class="hljs-comment">// the validation is going to fail.</span>
  }
);

<span class="hljs-comment">// Using regular expressions to validate error properties:</span>
throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> err;
  },
  {
    <span class="hljs-comment">// The `name` and `message` properties are strings and using regular</span>
    <span class="hljs-comment">// expressions on those will match against the string. If they fail, an</span>
    <span class="hljs-comment">// error is thrown.</span>
    <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^TypeError$/</span>,
    message: <span class="hljs-regexp">/Wrong/</span>,
    foo: <span class="hljs-string">&#x27;bar&#x27;</span>,
    <span class="hljs-attr">info</span>: {
      <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-comment">// It is not possible to use regular expressions for nested properties!</span>
      <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
    },
    <span class="hljs-comment">// The `reg` property contains a regular expression and only if the</span>
    <span class="hljs-comment">// validation object contains an identical regular expression, it is going</span>
    <span class="hljs-comment">// to pass.</span>
    <span class="hljs-attr">reg</span>: <span class="hljs-regexp">/abc/i</span>
  }
);

<span class="hljs-comment">// Fails due to the different `message` and `name` properties:</span>
throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> otherErr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Not found&#x27;</span>);
    <span class="hljs-comment">// Copy all enumerable properties from `err` to `otherErr`.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(err)) {
      otherErr[key] = value;
    }
    <span class="hljs-keyword">throw</span> otherErr;
  },
  <span class="hljs-comment">// The error&#x27;s `message` and `name` properties will also be checked when using</span>
  <span class="hljs-comment">// an error as validation object.</span>
  err
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
err.code = <span class="hljs-number">404</span>;
err.foo = <span class="hljs-string">&#x27;bar&#x27;</span>;
err.info = {
  <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
};
err.reg = <span class="hljs-regexp">/abc/i</span>;

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> err;
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TypeError&#x27;</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Wrong value&#x27;</span>,
    <span class="hljs-attr">info</span>: {
      <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
    }
    <span class="hljs-comment">// Only properties on the validation object will be tested for.</span>
    <span class="hljs-comment">// Using nested objects requires all properties to be present. Otherwise</span>
    <span class="hljs-comment">// the validation is going to fail.</span>
  }
);

<span class="hljs-comment">// Using regular expressions to validate error properties:</span>
throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> err;
  },
  {
    <span class="hljs-comment">// The `name` and `message` properties are strings and using regular</span>
    <span class="hljs-comment">// expressions on those will match against the string. If they fail, an</span>
    <span class="hljs-comment">// error is thrown.</span>
    <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^TypeError$/</span>,
    message: <span class="hljs-regexp">/Wrong/</span>,
    foo: <span class="hljs-string">&#x27;bar&#x27;</span>,
    <span class="hljs-attr">info</span>: {
      <span class="hljs-attr">nested</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-comment">// It is not possible to use regular expressions for nested properties!</span>
      <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;text&#x27;</span>
    },
    <span class="hljs-comment">// The `reg` property contains a regular expression and only if the</span>
    <span class="hljs-comment">// validation object contains an identical regular expression, it is going</span>
    <span class="hljs-comment">// to pass.</span>
    <span class="hljs-attr">reg</span>: <span class="hljs-regexp">/abc/i</span>
  }
);

<span class="hljs-comment">// Fails due to the different `message` and `name` properties:</span>
throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> otherErr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Not found&#x27;</span>);
    <span class="hljs-comment">// Copy all enumerable properties from `err` to `otherErr`.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(err)) {
      otherErr[key] = value;
    }
    <span class="hljs-keyword">throw</span> otherErr;
  },
  <span class="hljs-comment">// The error&#x27;s `message` and `name` properties will also be checked when using</span>
  <span class="hljs-comment">// an error as validation object.</span>
  err
);
</div></code></pre>
  <p>Validate instanceof using constructor:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">Error</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-built_in">Error</span>
);
</div></code></pre>
  <p>Validate error message using <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>:
  </p>
  <p>Using a regular expression runs <code>.toString</code> on the error object, and will
    therefore also include the error name.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-regexp">/^Error: Wrong value$/</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-regexp">/^Error: Wrong value$/</span>
);
</div></code></pre>
  <p>Custom error validation:</p>
  <p>The function must return <code>true</code> to indicate all internal validations passed.
    It will otherwise fail with an <a href="#class-assertassertionerror"><code>AssertionError</code></a>.</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    assert(err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>);
    assert(<span class="hljs-regexp">/value/</span>.test(err));
    <span class="hljs-comment">// Avoid returning anything from validation functions besides `true`.</span>
    <span class="hljs-comment">// Otherwise, it&#x27;s not clear what part of the validation failed. Instead,</span>
    <span class="hljs-comment">// throw an error about the specific validation that failed (as done in this</span>
    <span class="hljs-comment">// example) and add as much helpful debugging information to that error as</span>
    <span class="hljs-comment">// possible.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
  <span class="hljs-string">&#x27;unexpected error&#x27;</span>
);
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

assert.throws(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Wrong value&#x27;</span>);
  },
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    assert(err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>);
    assert(<span class="hljs-regexp">/value/</span>.test(err));
    <span class="hljs-comment">// Avoid returning anything from validation functions besides `true`.</span>
    <span class="hljs-comment">// Otherwise, it&#x27;s not clear what part of the validation failed. Instead,</span>
    <span class="hljs-comment">// throw an error about the specific validation that failed (as done in this</span>
    <span class="hljs-comment">// example) and add as much helpful debugging information to that error as</span>
    <span class="hljs-comment">// possible.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
  <span class="hljs-string">&#x27;unexpected error&#x27;</span>
);
</div></code></pre>
  <p><code>error</code> cannot be a string. If a string is provided as the second
    argument, then <code>error</code> is assumed to be omitted and the string will be used for
    <code>message</code> instead. This can lead to easy-to-miss mistakes. Using the same
    message as the thrown error message is going to result in an
    <code>ERR_AMBIGUOUS_ARGUMENT</code> error. Please read the example below carefully if using
    a string as the second argument gets considered:</p>
  <pre><code class="language-mjs"><div><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;assert/strict&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwingFirst</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;First&#x27;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwingSecond</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Second&#x27;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notThrowing</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// The second argument is a string and the input function threw an Error.</span>
<span class="hljs-comment">// The first case will not throw as it does not match for the error message</span>
<span class="hljs-comment">// thrown by the input function!</span>
assert.throws(throwingFirst, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// In the next example the message has no benefit over the message from the</span>
<span class="hljs-comment">// error and since it is not clear if the user intended to actually match</span>
<span class="hljs-comment">// against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.</span>
assert.throws(throwingSecond, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// TypeError [ERR_AMBIGUOUS_ARGUMENT]</span>

<span class="hljs-comment">// The string is only used (as message) in case the function does not throw:</span>
assert.throws(notThrowing, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Missing expected exception: Second</span>

<span class="hljs-comment">// If it was intended to match for the error message do this instead:</span>
<span class="hljs-comment">// It does not throw because the error messages match.</span>
assert.throws(throwingSecond, <span class="hljs-regexp">/Second$/</span>);

<span class="hljs-comment">// If the error message does not match, an AssertionError is thrown.</span>
assert.throws(throwingFirst, <span class="hljs-regexp">/Second$/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]</span>
</div></code></pre>
  <pre><code class="language-cjs"><div><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert/strict&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwingFirst</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;First&#x27;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwingSecond</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Second&#x27;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notThrowing</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// The second argument is a string and the input function threw an Error.</span>
<span class="hljs-comment">// The first case will not throw as it does not match for the error message</span>
<span class="hljs-comment">// thrown by the input function!</span>
assert.throws(throwingFirst, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// In the next example the message has no benefit over the message from the</span>
<span class="hljs-comment">// error and since it is not clear if the user intended to actually match</span>
<span class="hljs-comment">// against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.</span>
assert.throws(throwingSecond, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// TypeError [ERR_AMBIGUOUS_ARGUMENT]</span>

<span class="hljs-comment">// The string is only used (as message) in case the function does not throw:</span>
assert.throws(notThrowing, <span class="hljs-string">&#x27;Second&#x27;</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]: Missing expected exception: Second</span>

<span class="hljs-comment">// If it was intended to match for the error message do this instead:</span>
<span class="hljs-comment">// It does not throw because the error messages match.</span>
assert.throws(throwingSecond, <span class="hljs-regexp">/Second$/</span>);

<span class="hljs-comment">// If the error message does not match, an AssertionError is thrown.</span>
assert.throws(throwingFirst, <span class="hljs-regexp">/Second$/</span>);
<span class="hljs-comment">// AssertionError [ERR_ASSERTION]</span>
</div></code></pre>
  <p>Due to the confusing error-prone notation, avoid a string as the second
    argument.</p>

</body>

</html>